////////// Аргументы функций:
Позиционные аргументы
def print_name(first_name, last_name): 
  print(first_name, last_name)
 
print_name('Jiho', 'Baggins')


Аргументы ключевых слов
def print_name(first_name, last_name): 
  print(first_name, last_name)
 
print_name(last_name='Baggins', first_name='Jiho')

Аргументы по умолчанию
def print_name(first_name='Jiho', last_name='Baggins'): 
  print(first_name, last_name)
 
print_name()


tables = {
  1: ['Jiho', False],
  2: [],
  3: [],
  4: [],
  5: [],
  6: [],
  7: [],
}
print(tables)


def assign_table(table_number, name, vip_status=False): 
  tables[table_number] =  [name, vip_status]

assign_table(6, 'Yoni', False)
assign_table(table_number = 3, name = 'Martha', vip_status = True)
assign_table(4, 'Karla')
print(tables)

///////////// Переменное количество аргументов: *args

def my_function(*args):
  print(args) // ('Arg1', 245, False)
  
my_function('Arg1', 245, False)
//

def print_order(*order_items):
  print(order_items) // ('Orange Juice', 'Apple Juice', 'Scrambled Eggs', 'Pancakes')

print_order('Orange Juice', 'Apple Juice', 'Scrambled Eggs', 'Pancakes')
//

def shout_strings(*args):
  for argument in args:
    print(argument.upper()) // WORKING ON, LEARNING, ARGUMENT UNPACKING!
 
shout_strings('Working on', 'learning', 'argument unpacking!') 


def truncate_sentences(length, *sentences):
  for sentence in sentences:
    print(sentence[:length]) // What's g, Looks li
 
truncate_sentences(8, "What's going on here", "Looks like we've been cut off")

//
tables = {
  1: {
    'name': 'Jiho',
    'vip_status': False,
    'order': 'Orange Juice, Apple Juice'
  },
  2: {},
  3: {},
  4: {},
  5: {},
  6: {},
  7: {},
}
print(tables)

def assign_table(table_number, name, vip_status=False): 
  tables[table_number]['name'] = name
  tables[table_number]['vip_status'] = vip_status
  tables[table_number]['order'] = ''

# Write your code below: 
def assign_and_print_order(table_number, *order_items):
  tables[table_number]['order'] = order_items
  for order in order_items:
    print(order)

assign_table(2, 'Arwa', True)

assign_and_print_order(2, 'Steak', 'Seabass', 'Wine Bottle')
print(tables)

////////// Переменное количество аргументов: ** kwargs

def arbitrary_keyword_args(**kwargs):
  print(type(kwargs))
  print(kwargs)
  print(kwargs.get('anything_goes'))
 
arbitrary_keyword_args(this_arg='wowzers', anything_goes=101)
// output 
<class 'dict'>
{'this_arg': 'wowzers', 'anything_goes': 101}
101


tables = {
  1: {
    'name': 'Chioma',
    'vip_status': False,
    'order': {
      'drinks': 'Orange Juice, Apple Juice',
      'food_items': 'Pancakes'
    }
  },
  2: {},
  3: {},
  4: {},
  5: {},
  6: {},
  7: {},
}
print(tables)

def assign_food_items(**order_items):
  food = order_items.get('food')
  drinks = order_items.get('drinks')
  print(order_items)
  print(food)
  print(drinks)

assign_food_items(food='Pancakes, Poached Egg', drinks='Water')

//

def print_data(**data):
  for arg in data.values():
    print(arg) // arg1, True, 100
 
print_data(a='arg1', b=True, c=100)


def print_data(positional_arg, **data):
  print(positional_arg)
  for arg in data.values():
    print(arg) // position 1, arg1, True, 100
 
print_data('position 1', a='arg1', b=True, c=100)


tables = {
  1: {
    'name': 'Chioma',
    'vip_status': False,
    'order': {
      'drinks': 'Orange Juice, Apple Juice',
      'food_items': 'Pancakes'
    }
  },
  2: {},
  3: {},
  4: {},
  5: {},
  6: {},
  7: {},
}

def assign_table(table_number, name, vip_status=False): 
  tables[table_number]['name'] = name
  tables[table_number]['vip_status'] = vip_status
  tables[table_number]['order'] = {}

assign_table(2, 'Douglas', True)
print('--- tables with Douglas --- \n', tables)

def assign_food_items(table_number, **order_items):
  food = order_items.get('food')
  drinks = order_items.get('drinks')
  tables[table_number]['order']['food_items'] = food
  tables[table_number]['order']['drinks'] = drinks

print('\n --- tables after update --- \n')

assign_food_items(2, food = 'Seabass, Gnocchi, Pizza', drinks = 'Margarita, Water')
print(tables)

//

def print_animals(animal1, animal2, *args, animal4, **kwargs):
  print(animal1, animal2)
  print(args)
  print(animal4)
  print(kwargs)

print_animals('Snake', 'Fish', 'Guinea Pig', 'Owl', animal4='Cat', animal5='Dog') //output Snake Fish, ('Guinea Pig', 'Owl'), Cat, {'animal5': 'Dog'}

def single_prix_fixe_order(appetizer, *entrees, sides, **dessert_scoops):
  print(appetizer)
  print(entrees)
  print(sides)
  print(dessert_scoops)

single_prix_fixe_order('Baby Beets', 'Salmon', 'Scallops', sides = 'Mashed Potatoes', iceream_scoop_1 = 'Vanilla', iceream_scoop_2 = 'Cookies and Cream')

///////// Распаковка вызовов функций:

numbers  = {'num1': 3, 'num2': 6, 'num3': 9}
def sum(num1, num2, num3):
  print(num1 + num2 + num3) // 18
 
sum(**numbers)


start_and_stop = [3, 6]
range_values = range(*start_and_stop)
print(list(range_values)) // [3, 4, 5]


 a, *b, c = [3, 6, 9, 12, 15]
 print(b) // [6, 9, 12]


my_tuple = (3, 6, 9)
merged_tuple = (0, *my_tuple, 12)
print(merged_tuple) // (0, 3, 6, 9, 12)


num_collection = [3, 6, 9]
def power_two(*nums): 
  for num in nums:
    print(num**2) // 9 36 81
 
power_two(*num_collection)


def calculate_price_per_person(total, tip, split):
  total_tip = total * (tip/100)
  split_price = (total + total_tip) / split
  print(split_price)

table_7_total = [534.50, 20.0, 5]

calculate_price_per_person(*table_7_total)

///////////// Введение в имена и пространства имен:

// Встроенное пространство имен

print(dir(__builtins__))

// Глобальное пространство имен

print(globals())

// Локальное пространство имен 

print(locals())

// Включение пространства имен

global_variable = 'global'
 
def outer_function():
  outer_value = "outer"
 
  def inner_function():
    inner_value = "inner"

    def inner_nested_function():
      nested_value = 'nested'
    inner_nested_function()
    print(locals())
  inner_function()
 
outer_function()

// Локальный охват

def painting(paint_colors, picture):
  painting_statement = "To paint the " + picture + " we need the following colors: "
  print(painting_statement)
  for color in paint_colors:
      print(color)

painting(['Orange', 'White', 'Green'], 'Indian Flag')

// Охватывающая / нелокальная область видимости

def calc_paint_amount(width, height):
  square_feet = width * height
  def calc_gallons():
      return square_feet / 400

  return calc_gallons()


print('Number of paint gallons needed: ')
print(str(calc_paint_amount(30,20)))

// Изменение поведения области действия

walls = [(20, 9), (25, 9), (20, 9), (25, 9)]


def calc_paint_amount(wall_measurements):

  square_feet = 0

  def calc_square_feet():
    
    for width, height in wall_measurements:
      nonlocal square_feet <----------------------------
      square_feet += width * height

  def calc_gallons():
    return square_feet / 400

  calc_square_feet()

  return calc_gallons()


print('Number of paint gallons needed: ')
print(str(calc_paint_amount(walls)))

// Глобальный масштаб

paint_gallons_available = {
    'red': 50,
    'blue': 72,
    'green': 99,
    'yellow': 33
}
def print_available(color):

  print('There are ' + str(paint_gallons_available[color]) + ' gallons available of ' + color + ' paint.')


def print_all_colors_available():
  for color in paint_gallons_available:
    print(color)

print_available('red')
print_all_colors_available()

// Изменение поведения области действия

global_var = 10
def some_function():
  global_var = 20
some_function()
 
print(global_var) // 10

global_var = 10
def some_function():
  global global_var
  global_var = 20
some_function()
 
print(global_var) // 20


def print_available(color):
  global paint_gallons_available
  paint_gallons_available = {
    'red': 50,
    'blue': 72,
    'green': 99,
    'yellow': 33
  }
  print('There are ' + str(paint_gallons_available[color]) + ' gallons available of ' + color + ' paint.')


print_available('red')
for color in paint_gallons_available:
  print(color)

// Разрешение области действия: правило LEGB

color = 'green'

def change_color(new_color):
  global color
  # Checkpoint #2
  to_update = new_color
  
  def disp_color():
    print('The original color was: ' + color)

  disp_color()
  # Checkpoint #3
  color = to_update
  print('The new color is: ' + color)

change_color('blue')

// 

def add_two(my_input):
  return my_input + 2

OR WE CAN USE THIS: 

add_two = lambda my_input: my_input + 2

print(add_two(3))
print(add_two(100))
print(add_two(-2)) // output 5, 102, 0


check_if_A_grade = lambda grade: 'Got an A!' if grade >= 90 else 'Did not get an A.'

// Введение в функции высшего порядка:

# Here, we assign a function to a variable
uppercase = str.upper 
 
# And then call it 
big_pie = uppercase("pumpkinpie")


// Функции как аргументы:

def total_bill(func, value):
  total = func(value)
  return total

def add_tax(total):
  tax = total * 0.06
  new_total = total + tax
  return new_total
 
total_bill(add_tax, 100) // output 106.0


def total_bill(func, value):
  total = func(value)
  return ("The total amount owed is $" + "{:.2f}".format(total) + ". Thank you! :)")
 
 
print(total_bill(add_tax, 100)) // 'The total amount owed is $106.00. Thank you! :)'

// Функции как аргументы - итерация:

bills = [115, 120, 42]
 
new_bills = []
 
for i in range(len(bills)):
  total = add_tax(bills[i])
  new_bills.append("Total amount owed is $" + "{:.2f}".format(total) + ". Thank you! :)")
 
print(new_bills) // output ['Total amount owed is $121.90. Thank you! :)', 'Total amount owed is $127.20. Thank you! :)', 'Total amount owed is $44.52. Thank you! :)']


def total_bills(func, list):
  # This list will store all the new bill values
  new_bills = []
 
  # This loop will iterate through our bills
  for i in range(len(list)):
 
    # Here we apply the function to each element of the list!
    total = func(list[i])
    new_bills.append("Total amount owed is $" + "{:.2f}".format(total) + ". Thank you! :)")
 
  return new_bills

bills = [115, 120, 42]
 
bills_w_tax = total_bills(add_tax, bills)
 
print(bills_w_tax) ['Total amount owed is $121.90. Thank you! :)', 'Total amount owed is $127.20. Thank you! :)', 'Total amount owed is $44.52. Thank you! :)']

// Функции как возвращаемые значения:

def make_box_volume_function(height):
    # defines and returns a function that takes two numeric arguments,        
    # length &  width, and returns the volume given the input height
    def volume(length, width):
        return length*width*height
 
    return volume
 
box_volume_height15 = make_box_volume_function(15)
 
print(box_volume_height15(3,2)) // 90

// map():

Функция map()высшего порядка имеет следующую базовую структуру:
returned_map_object = map(function, iterable)

def double(x):
 return x*2
 
int_list = [3, 6, 9]
 
doubled = map(double, int_list)
 
print(doubled) // <map at 0x7f1ca0f58090>
OR WE CAN USE THIS TO HAVE NORMAL OUTPUT: print(list(doubled)) // [6, 12, 18]

also we can create that function:

doubled = map(lambda input: input*2, int_list)
print(list(doubled)) // [6, 12, 18]

grade_list = [3.5, 3.7, 2.6, 95, 87]

grades_100scale = map(lambda grade: grade* 25 if grade < 25 else grade, grade_list)

updated_grade_list = list(grades_100scale)
print(updated_grade_list)

// filter():

функция принимает в качестве аргументов функцию и итерацию. Как следует из названия, цель filter() функции - «отфильтровать» значения из итерируемого объекта.

names = ["margarita", "Linda", "Masako", "Maki", "Angela"]
M_names = filter(lambda name: name[0] == "M" or name[0] == "m", names) 

print(list(M_names)) // ['margarita', 'Masako', 'Maki']
/
books = [["Burgess", 1985],
 ["Orwell", "Nineteen Eighty-four"],
  ["Murakami", "1Q85"],
   ["Orwell", 1984],
    ["Burgess", "Nineteen Eighty-five"],
     ["Murakami", 1985]]

string_titles = filter(lambda book: type(book[1]) != int, books)
string_titles_list = list(string_titles)
print(string_titles_list)

// reduce():

В отличие от map() и filter() функций, которые всегда доступны, то reduce() функция должна быть импортированы из functools модуля , чтобы использовать его.
Вместо того, чтобы возвращать reduce объект, как можно было бы ожидать после изучения map() и filter(), reduce() возвращает единственное значение. 

from functools import reduce
int_list = [3, 6, 9, 12]
reduced_int_list = reduce(lambda x,y: x*y, int_list)

print(reduced_int_list) // 1944

//////////////////////// OOP

// Введение в объектно-ориентированное программирование

class Employee:
  new_id = 1
  def __init__(self):
    self.id = Employee.new_id
    Employee.new_id += 1

  def say_id(self):
    print('My id is ' + str(self.id))


e1 = Employee()
e1.say_id()
e2 = Employee()
e2.say_id()

// Столб ООП: наследование:

class Animal: 
  def eat(self): 
    print("Nom Nom Nom...eating food!")

class Dog(Animal):
  def bark(self):
    print('Bark!')
 
class Cat(Animal):
  def meow(self):
    print('Meow!')

fluffy = Dog()
zoomie = Cat()
 
fluffy.eat() # Nom Nom Nom...eating food!
zoomie.eat() # Nom Nom Nom...eating food!
/ 
class Employee():
  new_id = 1
  def __init__(self):
    self.id = Employee.new_id
    Employee.new_id += 1

  def say_id(self):
    print("My id is {}.".format(self.id))

class Admin(Employee):
  pass

e1 = Employee()
e2 = Employee()
e3 = Admin()

e3.say_id() // My id is 3.

// Переопределение методов:

class Animal:
  def __init__(self, name):
    self.name = name
 
  def make_noise(self):
    print("{} says, Grrrr".format(self.name))
 
pet1 = Animal("Rex")
pet1.make_noise() # Rex says, Grrrr
/
class Cat(Animal):
 
  def make_noise(self):
    print("{} says, Meow!".format(self.name))
 
pet2 = Cat("Maisy")
pet2.make_noise() # Maisy says, Meow!
/
class Employee():
  new_id = 1
  def __init__(self):
    self.id = Employee.new_id
    Employee.new_id += 1

  def say_id(self):
    print("My id is {}.".format(self.id))

class Admin(Employee):
  # Write your code below
  def say_id(self):
    print("I am an Admin")

e1 = Employee()
e2 = Employee()
e3 = Admin()
e3.say_id() // I am an Admin 

//  super():

class Animal:
  def __init__(self, name, sound="Grrrr"):
    self.name = name
    self.sound = sound
 
  def make_noise(self):
    print("{} says, {}".format(self.name, self.sound))
 
class Cat(Animal):
  def __init__(self, name):
    super().__init__(name, "Meow!") <----------------------
 
pet_cat = Cat("Rachel")
pet_cat.make_noise() # Rachel says, Meow!
/
class Employee():
  new_id = 1
  def __init__(self):
    self.id = Employee.new_id
    Employee.new_id += 1

  def say_id(self):
    print("My id is {}.".format(self.id))

class Admin(Employee):
  def say_id(self):
    super().say_id()
    print("I am an admin.")

e1 = Employee()
e2 = Employee()
e3 = Admin()
e3.say_id() // My id is 3., I am an admin.

// Множественное наследование:

class Animal:
  def __init__(self, name):
    self.name = name
 
  def say_hi(self):
    print("{} says, Hi!".format(self.name))
 
class Cat(Animal):
  pass
 
class Angry_Cat(Cat):
  pass
 
my_pet = Angry_Cat("Mr. Cranky")
my_pet.say_hi() # Mr. Cranky says, Hi!
/
class Employee():
  new_id = 1
  def __init__(self):
    self.id = Employee.new_id
    Employee.new_id += 1

  def say_id(self):
    print("My id is {}.".format(self.id))

class Admin(Employee):
  def say_id(self):
    super().say_id()
    print("I am an admin.")

# Write your code below
class Manager(Admin):
  def say_id(self):
    print('I am in charge')
    super().say_id()

e1 = Employee()
e2 = Employee()
e3 = Admin()
e4 = Manager()
e4.say_id() // I am in charge, My id is 4., I am an admin.
/
class Animal:
  def __init__(self, name):
    self.name = name
 
class Dog(Animal):
  def action(self):
    print("{} wags tail. Awwww".format(self.name))
 
class Wolf(Animal):
  def action(self):
    print("{} bites. OUCH!".format(self.name))
 
class Hybrid(Dog, Wolf):
  def action(self):
    super().action()
    Wolf.action(self)
 
my_pet = Hybrid("Fluffy")
my_pet.action() # Fluffy wags tail. Awwww
                # Fluffy bites. OUCH!
                
/
class Employee():
  new_id = 1
  def __init__(self):
    self.id = Employee.new_id
    Employee.new_id += 1

  def say_id(self):
    print("My id is {}.".format(self.id))

class User:
  def __init__(self, username, role="Customer"):
    self.username = username
    self.role = role

  def say_user_info(self):
    print("My username is {}".format(self.username))
    print("My role is {}".format(self.role))

# Write your code below
class Admin(Employee, User):
  def __init__(self):
    super().__init__()
    User.__init__(self, self.id, "Admin")

  def say_id(self):
    super().say_id()
    print("I am an admin.")

e1 = Employee()
e2 = Employee()
e3 = Admin()
e3.say_user_info() // My username is 3, My role is Admin

// Столб ООП: полиморфизм:

class Animal:
  def __init__(self, name):
    self.name = name
 
  def make_noise(self):
    print("{} says, Grrrr".format(self.name))
 
class Cat(Animal):
 
  def make_noise(self):
    print("{} says, Meow!".format(self.name))
 
class Robot:
 
  def make_noise(self):
    print("beep.boop...BEEEEP!!!")

an_animal = Animal("Bear")
my_pet = Cat("Maisy")
my_vacuum = Robot()
objects = [an_animal, my_pet, my_vacuum]
for o in objects:
  o.make_noise()
 
# OUTPUT
# "Bear says, Grrrr"
# "Maisy says, Meow!"
# "beep.boop...BEEEEP!!!"
/
class Employee():
  new_id = 1
  def __init__(self):
    self.id = Employee.new_id
    Employee.new_id += 1

  def say_id(self):
    print("My id is {}.".format(self.id))

class Admin(Employee):
  def say_id(self):
    super().say_id()
    print("I am an admin.")

class Manager(Admin):
  def say_id(self):
    super().say_id()
    print("I am in charge!")

meeting = [Employee(), Admin(), Manager()]

for m in meeting:
  m.say_id()

// Методы Дандера:

# For an int and an int, + returns an int
2 + 4 == 6
 
# For a string and a string, + returns a string
"Is this " + "addition?" == "Is this addition?"
 
# For a list and a list, + returns a list
[1, 2] + [3, 4] == [1, 2, 3, 4]

/

class Animal:
  def __init__(self, name):
    self.name = name
 
  def __add__(self, another_animal):
    return Animal(self.name + another_animal.name)
 
a1 = Animal("Horse")
a2 = Animal("Penguin")
a3 = a1 + a2
print(a1) # Horse
print(a2) # Penguin
print(a3) # HorsePenguin

/

class Employee():
  new_id = 1
  def __init__(self):
    self.id = Employee.new_id
    Employee.new_id += 1

class Meeting:
  def __init__(self):
    self.attendees = []
  
  def __add__(self, employee):
    print("ID {} added.".format(employee.id))
    self.attendees.append(employee)

  # Write your code
  def __len__(self):
    return len(self.attendees)
    
e1 = Employee()
e2 = Employee()
e3 = Employee()
m1 = Meeting()

m1 + e1
m1 + e2
m1 + e3
print(len(m1)) // ID 1 added., ID 2 added., ID 3 added., 3

// Столб ООП: Абстракция:

from abc import ABC, abstractmethod
 
class Animal(ABC):
  def __init__(self, name):
    self.name = name
 
  @abstractmethod
  def make_noise(self):
    pass
 
class Cat(Animal):
  def make_noise(self):
    print("{} says, Meow!".format(self.name))
 
class Dog(Animal):
  def make_noise(self):
    print("{} says, Woof!".format(self.name))
 
kitty = Cat("Maisy")
doggy = Dog("Amber")
kitty.make_noise() # "Maisy says, Meow!"
doggy.make_noise() # "Amber says, Woof!"

IF WE WRITE SMTH LIKE THAT: 
an_animal = Animal("Scruffy")
# TypeError: Can't instantiate abstract class Animal with abstract method make_noise

/

from abc import ABC, abstractmethod

class AbstractEmployee(ABC):
  new_id = 1
  def __init__(self):
    self.id = AbstractEmployee.new_id
    AbstractEmployee.new_id += 1

  @abstractmethod
  def say_id(self):
    pass

# Write your code below
class Employee(AbstractEmployee):
    def say_id(self):
      print("The id is {}".format(self.id))


e1 = Employee()
e1.say_id()

// Столб ООП: инкапсуляция:

class Employee():
    def __init__(self):
        self.id = None // Общественные
        self._id = '2-nd from end' // Защищено
        self.__id = 'aboba' // Частный

e = Employee()
print(dir(e))

// Геттеры, сеттеры и удалители:

class Animal:
  def __init__(self, name):
    self._name = name
    self._age = None
 
  def get_age(self):
    return self._age
 
  def set_age(self, new_age):
    if isinstance(new_age, int):
      self._age = new_age
    else:
      raise TypeError
 
  def delete_age(self):
    print("_age Deleted")
    del self._age

a = Animal("Rufus")
print(a.get_age()) # None
 
a.set_age(10)
print(a.get_age()) # 10
 
a.set_age("Ten") # Raises a TypeError
 
a.delete_age() # "_age Deleted"
print(a.get_age()) # Raises a AttributeError

/

class Employee():
  new_id = 1
  def __init__(self, name=None):
    self.id = Employee.new_id
    Employee.new_id += 1
    self._name = name

  # Write your code below
  def get_name(self):
    return self._name
  
  def set_name(self, new_name):
    self._name = new_name

  def del_name(self):
    del self._name


e1 = Employee("Maisy")
e2 = Employee()



e1 = Employee("Maisy")
e2 = Employee()
print(e1.get_name())

e2.set_name("Fluffy")
print(e2.get_name())

e2.del_name()
print(e2.get_name())

// Декоратор @property:

Начнем с рассмотрения примера класса, вызываемого Boxс одним вызываемым атрибутом weight. 
В этом случае weightэто будет частный атрибут с геттером и сеттером ( getWeight()и setWeight()).

class Box:
  def __init__(self, weight):
    self.__weight = weight
 
  def getWeight(self):
    return self.__weight
 
  def setWeight(self, weight):
    if weight >= 0:
      self.__weight = weight
      
Мы хотим следовать лучшим практикам, обозначая вес как частный атрибут, используя __(dunder) нотацию.
box = Box(10)
 
box.setWeight(-5) 
print(box.getWeight()) // 10
 
box.setWeight(5)
print(box.getWeight()) // 5

// Встроенная функция property ():

Python встроенных property()функций принимает четыре необязательных аргумента: fget, fset, fdel, и doc. 
Первые три представляют методы получения, установки и удаления соответственно, а последний - это строка документации для атрибута.

class Box:
  def __init__(self, weight):
    self.__weight = weight
 
  def getWeight(self):
    return self.__weight
 
  def setWeight(self, weight):
    if weight >= 0:
      self.__weight = weight
 
  def delWeight(self):
    del self.__weight
 
  weight = property(getWeight, setWeight, delWeight, "Docstring for the 'weight' property")

box = Box(10)
print(box.weight) #this calls .getWeight()
box.weight = 5 #this called .setWeight()
del box.weight #this calls .delWeight()
box.weight = -5 #box.__weight is unchanged 

// @property Decorator:

class Box:
 def __init__(self, weight):
   self.__weight = weight
 
 @property
 def weight(self):
   """Docstring for the 'weight' property"""
   return self.__weight
 
 
 @weight.setter
 def weight(self, weight):
   if weight >= 0:
     self.__weight = weight
 
 @weight.deleter
 def weight(self):
   del self.__weight

Это эквивалент выполнения:
weight = property(getWeight, setWeight, delWeight,  "Docstring for the 'weight' property")

И, таким образом, дает нам то же синтаксическое преимущество, что и раньше:
box = Box(10)
box.weight = 5
del box.weight


// Введение в исключения

Исключения - это ошибки времени выполнения, потому что они возникают во время выполнения программы, 
только когда достигается неправильный код (код, вызывающий ошибку)

// Встроенные исключения

ольшинство исключений наследуются непосредственно от вызываемого класса Exception; 
однако все они прямо или косвенно являются производными от BaseExceptionкласса. 
Мы можем исследовать базовые классы, используя __bases__атрибут для любого конкретного исключения:

print(NameError.__bases__) // <class 'Exception'>

Мы можем даже назвать __bases__на Exceptionклассе , чтобы увидеть его происхождение:
print(Exception.__bases__) // <class 'BaseException'>


sale_instruments = ['Violin', 'Conga', 'Clavinet']

print('The following ' + str(len(sale_instruments)) + ' instruments are on sale:')
print(sale_instruments[0])
print(sale_instruments[1])
print(sale_instruments[2])
print(TypeError.__bases__)

// Вызов исключений:

Мы можем создать исключение в любое время, используя raise ключевое слово

Один из способов использования raise ключевого слова - связать его с определенным именем класса исключения. 
Мы можем либо вызвать класс сам по себе, либо вызвать конструктор и предоставить конкретное сообщение об ошибке.

raise NameError
# or 
raise NameError('Custom Message')

/

def open_register(employee_status):
  if employee_status == 'Authorized':
    print('Successfully opened cash register')
  else:
    # Alternatives: raise TypeError() or TypeError('Message')
    raise TypeError

OR

def open_register(employee_status):
  if employee_status == 'Authorized':
    print('Successfully opened cash register')
  else:
    raise Exception('Employee does not have access!')

/

instrument_catalog = {
  'Marimba': 1999,
  'Kora': 499,
  'Flute': 899
}

def print_instrument_price(instrument):
  # Write your code below:
  if instrument in instrument_catalog:
    print('The price of a ' + instrument + ' is ' + str(instrument_catalog[instrument]))
  else: raise KeyError(instrument + ' is not found in instrument catalog!')
print_instrument_price('Marimba')
print_instrument_price('Flute')
print_instrument_price('Piano')

// try/ except:

colors = {
    'red': '#FF0000',
    'blue': '#0000FF',
    'yellow': '#FFFF00',
}
 
for color in ('red', 'green', 'yellow'):
  try:
    print('The hex value of ' + color + ' is ' + colors[color])
  except:
    print('An exception occurred! Color does not exist.')
  print('Loop continues...')

// output
The hex value of red is #FF0000
Loop continues...
An exception occurred! Color does not exist.
Loop continues...
The hex value of yellow is #FFFF00
Loop continues...

/ 

staff = {
  'Austin': {
      'floor managers': 1,
      'sales associates': 5
  },
  'Melbourne': {
      'floor managers': 0,
      'sales associates': 8
  },
  'Beijing': {
      'floor managers': 2,
      'sales associates': 5
  },
}

def print_staff_report(location, staff_dict):
  managers = staff_dict['floor managers']
  sales_people = staff_dict['sales associates']
  ratio = sales_people / managers
  print('Instrument World ' + location + ' has:')
  print(str(sales_people) + ' sales employees')
  print(str(managers) + ' floor managers')
  print('The ratio of sales people to managers is ' + str(ratio))
  print()

for location, staff in staff.items():

  try:
    print_staff_report(location, staff)
  except:
    print('Could not print sales report for ' + location)

// Выявление особых исключений:

try:
    print(undefined_var)
except NameError:
    print('We hit a NameError')

В этом случае except блок выполняется, только если NameErrorвстречается (в try блоке), а не какое-либо исключение. 
Also we can use AS:

try:
    print(undefined_var)
except NameError as errorObject: <-----
    print('We hit a NameError')
    print(errorObject) // We hit a NameError, name 'undefined_var' is not defined

/

staff = {
  'Austin': {
    'floor managers': 1,
    'sales associates': 5
  },
  'Melbourne': {
    'floor managers': 0,
    'sales associates': 8
  },
  'Beijing': {
    'floor managers': 2,
    'sales associates': 5
  },
}

def print_staff_report(location, staff_dict):
  managers = staff_dict['floor managers']
  sales_people = staff_dict['sales associates']
  ratio = sales_people / managers
  print('Instrument World ' + location + ' has:')
  print(str(sales_people) + ' sales employees')
  print(str(managers) + ' floor managers')
  print('The ratio of sales people to managers is ' + str(ratio))
  print()

for location, staff in staff.items():
  try:
      print_staff_report(location, staff)

  except ZeroDivisionError as e:
      print('Could not print sales report for ' + location)
      print(e)

// Обработка множественных исключений:

Мы можем перечислить более одного типа исключения в кортеже с помощью одного except предложения. 

try:
    # Some code to try!
except (NameError, ZeroDivisionError) as e:
    print('We hit an Exception!')
    print(e)

Помимо перехвата нескольких исключений, мы также можем объединить несколько exceptпредложений с одним try предложением, 
что позволяет обрабатывать определенные исключения по-разному. 

try:
    # Some code to try!
except NameError:
    print('We hit a NameError Exception!')
except KeyError:
    print('We hit a TypeError Exception!')
except Exception:
    print('We hit an exception that is not a NameError or TypeError!')

/

instrument_prices = {
  'Banjo': 200,
  'Cello': 1000,
  'Flute': 100,
}

def display_discounted_price(instrument, discount):
  full_price = instrument_prices[instrument]
  discount_percentage = discount / 100
  discounted_price = full_price - (full_price * discount_percentage)
  print("The instrument's discounted price is: " + str(discounted_price))

instrument = 'Banjo'
discount = '20'


try:
  display_discounted_price(instrument, discount)
except KeyError: 
  print('An invalid instrument was entered!')
except TypeError:
  print('Discount percentage must be a number!')
except Exception:
  print('Hit an exception other than KeyError or TypeError!')

// Пункт else:

try:
  check_password()
except ValueError:
  print('Wrong Password! Try again!')
else:
  login_user()
  # 20 other lines of imaginary code

/

customer_rewards = {
  'Zoltan': 82570,
  'Guadalupe': 29850,
  'Mario': 17849
}

def display_rewards_account(customer):

  try:
    rewards_number = customer_rewards[customer]
    print('Rewards account number is: ' + str(rewards_number))
  except KeyError:
    print('Customer was not found in rewards program!')
  else:
    print('Rewards account number is: ' + str(rewards_number))

customer = 'Mario'
display_rewards_account(customer)

// finally предложение:

мы добавили finallyпредложение, которое будет выполняться независимо от того, не сможет ли пользователь войти в систему или нет. 
В любом случае мы используем воображаемую функцию, вызываемую load_footer() для загрузки нижнего колонтитула страницы. 

try:
  check_password()
except ValueError:
  print('Wrong Password! Try again!')
else:
  login_user()
  # 20 other lines of imaginary code
finally:
  load_footer()

also we can use it only with try:

try:
    check_password()
finally:
    load_footer()
    # Other code we always want to run 

/

import database

instrument = 'Kora'
database.connect_to_database()

try:
  database.display_instrument_info(instrument)
except KeyError:
  print('Oh no! This instrument does not exist.')
else:
  print(instrument)
finally:
  database.disconnect_from_database()

// Пользовательские исключения:

Python дает нам возможность создавать пользовательские исключения

class CustomError(Exception):
    pass

/

class LocationTooFarError(Exception):
   pass
 
def schedule_delivery(distance_from_store):
    if distance_from_store > 10:
        raise LocationTooFarError
    else:
        print('Scheduling the delivery...')

/

inventory = {
  'Piano': 3,
  'Lute': 1,
  'Sitar': 2
}

class InventoryError(Exception):
  pass

def submit_order(instrument, quantity):
  supply = inventory[instrument]

  if quantity > supply:
    raise InventoryError
  else:
    inventory[instrument] -= quantity
    print('Successfully placed order! Remaining supply: ' + str(inventory[instrument]))

instrument = 'Piano'
quantity = 5
submit_order(instrument, quantity)

// Настройка пользовательских исключений:

Вот как может выглядеть пользовательский класс:

class LocationTooFarError(Exception):
   def __init__(self, distance):
       self.distance = distance
 
   def __str__(self):
        return 'Location is not within 10 km: ' + str(self.distance)

/

class InventoryError(Exception):
  def __init__(self, supply):
    self.supply = supply

  def __str__(self):
    return 'Available supply is only ' + str(self.supply)

inventory = {
  'Piano': 3,
  'Lute': 1,
  'Sitar': 2
}

def submit_order(instrument, quantity):
  supply = inventory[instrument]

  if quantity > supply:
    raise InventoryError(supply)
  else:
    inventory[instrument] -= quantity
    print('Successfully placed order! Remaining supply: ' + str(inventory[instrument]))

instrument = 'Piano'
quantity = 5
submit_order(instrument, quantity)

/////////// Введение в тестирование:

Ручное тестирование:
При ручном тестировании физическое лицо взаимодействует с программным обеспечением так же, как пользователь. 

Автоматизированное тестирование:
При автоматическом тестировании тесты выполняются с кодом. Как правило, автоматическое тестирование выполняется быстрее и менее подвержено человеческим ошибкам.

flight_statuses = {
  903: 'Departed',
  834: 'Boarding',
  359: 'Delayed',
  128: 'On time',
  385: 'On time',
}

print('***Small World Air Flight Information***')
for flight, status in flight_statuses.items():
  print('Flight ' + str(flight) + ' status: ' + str(status))


// Заявление assert:

Python предоставляет простой способ выполнять простые тесты в нашем коде - assert оператор. 
assert Заявление может быть использовано для испытания , что условие удовлетворяется. 
Если условие оценивается как значение False, AssertionError возникает необязательное сообщение об ошибке.

def times_ten(number):
    return number * 100
 
result = times_ten(20)
assert result == 200, 'Expected times_ten(20) to return 200, instead got ' + str(result) <-------------

/

destinations = {
  'BUD': 'Budapest',
  'CMN': 'Casablanca',
  'IST': 'Istanbul'
}
print('Welcome to Small World Airlines!')
print('What is the airport code of your travel destination?')
destination = 'HND'

assert destination in destinations, 'Sorry, Small World currently does not fly to this destination!' <------------------------------
city_name = destinations[destination]
print('Great! Retrieving information for your flight to ...' + city_name)

// Модульное тестирование:

Модульный тест проверяет одно поведение и проверяет правильность работы всех модулей программы.

Example:
# The unit we want to test
def times_ten(number):
    return number * 100
# A unit test functions
def test_multiply_ten_by_zero():
    assert times_ten(0) == 0, 'Expected times_ten(0) to return 0'
def test_multiply_ten_by_one_million():
    assert times_ten(1000000) == 10000000, 'Expected times_ten(1000000) to return 10000000 
def test_multiply_ten_by_negative_number():
    assert times_ten(-10) == -100, 'Expected times_ten(-10) to return -100'

/

def get_nearest_exit(row_number):
  if row_number < 15:
    location = 'front'
  elif row_number < 30:
    location = 'middle'
  else:
    location = 'back'
  return location

def test_row_1():
  assert get_nearest_exit(1) == 'front', 'The nearest exit to row 1 is in the front!'

def test_row_20():
  assert get_nearest_exit(20) == 'middle', 'The nearest exit to row 20 is in the middle!'

def test_row_40():
  assert get_nearest_exit(40) == 'back', 'The nearest exit to row 40 is in the back!'

test_row_1()
test_row_20()
test_row_40()

// Фреймворк Python unittest:

Этот фреймворк находится в unittestмодуле, который входит в стандартную библиотеку. 

import unittest

Во-первых, давайте проведем рефакторинг наших тестов, чтобы times_ten функция использовала unittest фреймворк. Нам нужно сделать несколько вещей:
Во-первых, мы должны создать класс, который наследуется от unittest.TestCase следующего:

import unittest 
 
class TestTimesTen(unittest.TestCase):
    pass
Этот класс будет служить основным хранилищем всех наших функций модульного тестирования. 
Модуль требует , чтобы тестовые функции начинаются со слова 'test'

import unittest
 
class TestTimesTen(unittest.TestCase):
    def test_multiply_ten_by_zero(self):
        pass
 
    def test_multiply_ten_by_one_million(self):
        pass
 
    def test_multiply_ten_by_negative_number(self):
        pass

Наконец, нам нужно изменить наши assertоператоры, чтобы использовать assertEqual метод unittest.TestCase. 
Фреймворк требует, чтобы мы использовали специальные методы вместо стандартных assert операторов.

import unittest
 
class TestTimesTen(unittest.TestCase):
    def test_multiply_ten_by_zero(self):
        self.assertEqual(times_ten(0), 0, 'Expected times_ten(0) to return 0')
 
    def test_multiply_ten_by_one_million(self):
        self.assertEqual(times_ten(1000000), 10000000, 'Expected times_ten(1000000) to return 10000000')
 
    def test_multiply_ten_by_negative_number(self):
        self.assertEqual(times_ten(-10), -100, 'Expected add_times_ten(-10) to return -100')

Наш окончательный код будет выглядеть так:

# Importing unittest framework
import unittest
 
# Function that gets tested
def times_ten(number):
    return number * 100
 
# Test class
class TestTimesTen(unittest.TestCase):
    def test_multiply_ten_by_zero(self):
        self.assertEqual(times_ten(0), 0, 'Expected times_ten(0) to return 0')
 
    def test_multiply_ten_by_one_million(self):
        self.assertEqual(times_ten(1000000), 10000000, 'Expected times_ten(1000000) to return 10000000')
 
    def test_multiply_ten_by_negative_number(self):
        self.assertEqual(times_ten(-10), -100, 'Expected add_times_ten(-10) to return -100')
 
# Run the tests
unittest.main()

/

import unittest
def get_nearest_exit(row_number):
  if row_number < 15:
    location = 'front'
  elif row_number < 30:
    location = 'middle'
  else:
    location = 'back'
  return location

class NearestExitTests(unittest.TestCase):
  def test_row_1(self):
    self.assertEqual(get_nearest_exit(1), 'front', 'The nearest exit to row 1 is in the front!')
  def test_row_20(self):
    self.assertEqual(get_nearest_exit(20), 'middle', 'The nearest exit to row 20 is in the middle!')
  def test_row_40(self):
    self.assertEqual(get_nearest_exit(40), 'back', 'The nearest exit to row 40 is in the back!')

unittest.main()

// Утверждать методы I: равенство и членство:

рассмотрим три часто используемых метода assert для проверки равенства и принадлежности

1) assertEqual : assertEqual() метод принимает два значения в качестве аргументов и проверяет их равенство. Если это не так, тест не пройден.
 self.assertEqual(value1, value2)

2) assertIn : assertIn() метод принимает два аргумента. Он проверяет, находится ли первый аргумент во втором аргументе, который должен быть контейнером. 
Если его нет в контейнере, тест не пройден.
 self.assertIn(value, container)

3) assertTrue : assertTrue() метод принимает единственный аргумент и проверяет, соответствует ли его значение True. Если он не оценивается True, тест не проходит.
 self.assertTrue(value)

self.assertEqual(2, 5)	=====  assert 2 == 5
self.assertIn(5, [1, 2, 3]) ===== 	assert 5 in [1, 2, 3]
self.assertTrue(0) ======= 	assert bool(0) is True

/

def get_daily_movie():
    print('Retrieving the movie set to play on today\'s flight...')
    return 'Parasite'


def get_licensed_movies():
    print('Retrieving the list of licensed movies from the database...')
    licensed_movies = ['Parasite', 'Nomadland', 'Roma']
    return licensed_movies


def get_wifi_status():
    print('Checking WiFi signal...')
    print('WiFi is inactive')
    return False

import unittest
import entertainment

class EntertainmentSystemTests(unittest.TestCase):

  def test_movie_license(self):
    daily_movie = entertainment.get_daily_movie()
    licensed_movies = entertainment.get_licensed_movies()
    self.assertIn(daily_movie, licensed_movies)


  def test_wifi_status(self):
    wifi_enabled = entertainment.get_wifi_status()
    self.assertTrue(wifi_enabled)

unittest.main()

// Методы утверждения II: количественные методы:

рассмотрим два распространенных метода assert, связанных с количественными сравнениями:
 
1) assertLess : assertLess() метод принимает два аргумента и проверяет, что первый аргумент меньше второго. Если это не так, тест не пройдёт.
 self.assertLess(value1, value2)

2) assertAlmostEqual : assertAlmostEqual() метод принимает два аргумента и проверяет, что их разница, округленная до 7 десятичных знаков, равна 0. 
Другими словами, если они почти равны. Если значение достаточно близко к равенству, тест не пройдёт.
 self.assertAlmostEqual(value1, value2)

self.assertLess(2, 5) =======	assert 2 < 5
self.assertAlmostEqual(.22, .225) ======	assert round(.22 - .225, 7) == 0

/

import unittest
import entertainment

class EntertainmentSystemTests(unittest.TestCase):

  def test_movie_license(self):
    daily_movie = entertainment.get_daily_movie()
    licensed_movies = entertainment.get_licensed_movies()
    self.assertIn(daily_movie, licensed_movies)

  def test_wifi_status(self):
    wifi_enabled = entertainment.get_wifi_status()
    self.assertTrue(wifi_enabled)

  # Write your code below:
  def test_maximum_display_brightness(self):
    brightness = entertainment.get_maximum_display_brightness()
    self.assertAlmostEqual(brightness, 400)

  def test_device_temperature(self):
    device_temp = entertainment.get_device_temp()
    self.assertLess(device_temp, 35)
unittest.main()

// Методы утверждения III: методы исключений и предупреждений:

еще одна группа методов assert, связанных с исключениями и предупреждениями.

1) assertRaises :
assertRaises() метод принимает тип исключения в качестве первого аргумента, ссылку на функцию в качестве второго и 
произвольное количество аргументов в качестве остальных.
Он вызывает функцию и проверяет, возникло ли в результате исключение. Тест проходит, если возникает исключение, является ошибкой,
если возникает другое исключение, или терпит неудачу, если исключение не возникает. Этот метод также можно использовать с настраиваемыми исключениями!

self.assertRaises(specificException, function, functionArguments...)

2) assertWarns :
assertWarns() метод принимает тип предупреждения в качестве первого аргумента, ссылку на функцию в качестве второго и 
произвольное количество аргументов для остальных.
Он вызывает функцию и проверяет появление предупреждения. Тест проходит успешно, если появляется предупреждение, и терпит неудачу, если его нет.

self.assertWarns(specificWarningException, function, functionArguments...)

/

import unittest
import alerts

class SystemAlertTests(unittest.TestCase):
  def test_power_outage_alert(self):
    self.assertRaises(alerts.PowerError, alerts.power_outage_detected, True)

  def test_water_levels_warning(self):
    self.assertWarns(alerts.WaterLevelWarning, alerts.water_levels_check, 150)

unittest.main()

// Параметризация тестов:

Чтобы уменьшить повторение, Python предоставляет нам специальный набор инструментов для тестов с небольшими отличиями. 
Это называется параметризацией теста . Параметризуя тесты, мы можем усилить функциональность одного теста, чтобы получить большой охват различных входных данных.

unittest фреймворк предоставляет нам subTest диспетчер контекста:

import unittest
 
# The function we want to test
def times_ten(number):
    return number * 100
 
# Our test class
class TestTimesTen(unittest.TestCase):
 
    # A test method
    def test_times_ten(self):
        for num in [0, 1000000, -10]:
            with self.subTest():
                expected_result = num * 10
                message = 'Expected times_ten(' + str(num) + ') to return ' + str(expected_result)
                self.assertEqual(times_ten(num), expected_result, message)

Здесь, в нашем методе испытаний test_times_ten(), вместо того , чтобы писать отдельные тестовые случаи для каждого входа 0, 10 и 1000000 
мы можем проверить набор входов с помощью цикла с последующим with утверждением и нашим subTest контекст менеджером.
При использовании subTest каждая итерация нашего цикла рассматривается как отдельный тест. 
Python будет запускать код внутри диспетчера контекста на каждой итерации, и если одна из них не удалась, 
он вернет ошибку как ошибку отдельного тестового примера.

import unittest
import entertainment

class EntertainmentSystemTests(unittest.TestCase):

  def test_movie_license(self):
    daily_movies = entertainment.get_daily_movies()
    licensed_movies = entertainment.get_licensed_movies()

    for movie in daily_movies:
      print(movie)
      with self.subTest(movie):
        self.assertIn(movie, licensed_movies)

unittest.main()

// Испытательные приспособления:

 Тестовые приспособления - это механизм, обеспечивающий правильную настройку теста (перевод тестов в известное состояние) и 
 разборку теста (восстановление состояния до запуска теста). Испытательные приспособления гарантируют, 
 что наши тесты выполняются в предсказуемых условиях, и, следовательно, результаты являются надежными.

def power_cycle_device():
    print('Power cycling bluetooth device...')
 
class BluetoothDeviceTests(unittest.TestCase):
    def setUp(self):
        power_cycle_device()
 
    def test_feature_a(self):
        print('Testing Feature A')
 
    def test_feature_b(self):
        print('Testing Feature B')
 
    def tearDown(self):
        power_cycle_device()

Tеперь мы можем гарантировать, что наш модуль Bluetooth находится в рабочем состоянии до и после каждого теста.

/

def power_cycle_device():
    print('Power cycling bluetooth device...')
 
class BluetoothDeviceTests(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        power_cycle_device() // Включаем 1 раз в начале
 
    def test_feature_a(self):
        print('Testing Feature A')
 
    def test_feature_b(self):
        print('Testing Feature B')
 
    @classmethod
    def tearDownClass(cls):
        power_cycle_device() // Выключаем 1 раз в конце


/

import unittest
import kiosk

class CheckInKioskTests(unittest.TestCase):

  def test_check_in_with_flight_number(self):
    print('Testing the check-in process based on flight number')

  def test_check_in_with_passport(self):
    print('Testing the check-in process based on passport')

  @classmethod
  def setUpClass(cls):
    kiosk.power_on_kiosk()

  def setUp(self):
    kiosk.return_to_welcome_page()

  @classmethod
  def tearDownClass(cls):
    kiosk.power_off_kiosk()

unittest.main()

// Пропуск тестов:

unittestСтруктура обеспечивает два различных способа пропустить тесты:

@unittest - Пропуском декоратор
skipTest() - метод

Во-первых, давайте рассмотрим опцию пропуска декоратора. Есть два варианта декоратора, позволяющие пропустить тест. Давайте рассмотрим их оба в примере ниже:

import sys
 
class LinuxTests(unittest.TestCase):
 
    @unittest.skipUnless(sys.platform.startswith("linux"), "This test only runs on Linux")
    def test_linux_feature(self):
        print("This test should only run on Linux")
 
    @unittest.skipIf(not sys.platform.startswith("linux"), "This test only runs on Linux")
    def test_other_linux_feature(self):
        print("This test should only run on Linux")

skipUnless Опция пропускает тест, если условие имеет значение False.
skipIf Опция пропускает тест, если условие имеет значение True.

Оба имеют общие требования. Во-первых, оба этих декоратора пропуска имеют предисловие @unittestдля обозначения шаблона декоратора. 
Оба они принимают условие в качестве первого аргумента, за которым следует строковое сообщение в качестве второго.
В этом примере оба декоратора достигают одной и той же цели: пропускать тест, если операционная система не Linux.

Второй способ пропустить тесты - вызвать skipTestметод TestCase класса, как в этом примере:

import sys
 
class LinuxTests(unittest.TestCase):
 
    def test_linux_feature(self):
        if not sys.platform.startswith("linux"):
            self.skipTest("Test only runs on Linux")

/

import unittest
import entertainment

class EntertainmentSystemTests(unittest.TestCase):

  @unittest.skipIf(entertainment.regional_jet(), 'Not available on regional jets')
  def test_movie_license(self):
    daily_movie = entertainment.get_daily_movie()
    licensed_movies = entertainment.get_licensed_movies()
    self.assertIn(daily_movie, licensed_movies)

  @unittest.skipUnless(entertainment.regional_jet() is False, 'Not available on regional jets')
  def test_wifi_status(self):
    wifi_enabled = entertainment.get_wifi_status()
    self.assertTrue(wifi_enabled)

  def test_device_temperature(self):
    if entertainment.regional_jet():
      self.skipTest('Not available on regional jets')
    device_temp = entertainment.get_device_temp()
    self.assertLess(device_temp, 35)

  def test_maximum_display_brightness(self):
    if entertainment.regional_jet():
      self.skipTest('Not available on regional jets')
    brightness = entertainment.get_maximum_display_brightness()
    self.assertAlmostEqual(brightness, 400)


unittest.main()

// Ожидаемые отказы:

unittest предоставляет способ пометить тесты как ожидаемые сбои. Ожидаемые сбои считаются пройденными в наших результатах тестирования.
Чтобы настроить тест на ожидаемый сбой, мы можем использовать expectedFailure декоратор 

class FeatureTests(unittest.TestCase):
 
    @unittest.expectedFailure
    def test_broken_feature(self):
        raise Exception("This test is going to fail")

/

import unittest
import feedback

class CustomerFeedbackTests(unittest.TestCase):

  @unittest.expectedFailure
  def test_survey_form(self):
    self.assertEqual(feedback.issue_survey(), 'Success')

  def test_complaint_form(self):
    self.assertEqual(feedback.log_customer_complaint(), 'Success')

unittest.main()

/

import unittest
import surfshop

class Tasks(unittest.TestCase):
  
  def setUp(self):
    self.cart = surfshop.ShoppingCart()

  def test_add_surfboard(self):
    message = self.cart.add_surfboards(quantity=1)
    self.assertEqual(message, 'Successfully added 1 surfboard to cart!')

  def test_add_surfboards(self):
    for i in range(2,5):
      with self.subTest(i=i):
        message = self.cart.add_surfboards(i)
        self.assertEqual(message, f'Successfully added {i} surfboards to cart!')
        self.cart = surfshop.ShoppingCart()
  
  @unittest.skip
  def test_add_too_many_surfboards(self):
    self.assertRaises(surfshop.TooManyBoardsError, self.cart.add_surfboards, 5)

  @unittest.expectedFailure
  def test_apply_locals_discount(self):
    self.cart.apply_locals_discount()
    self.assertTrue(self.cart.locals_discount)

unittest.main()

// итерируемые объекты:

В Python итерируемый объект - это объект, который может проходить цикл по одному элементу за раз. 

dog_foods = {
    "Great Dane Foods": 4,
    "Min Pin Pup Foods": 10,
    "Pawsome Pups Foods": 8
}

for food_brand in dog_foods:
    print(food_brand + " has " + str(dog_foods[food_brand]) + " bags")

// Объекты итератора: __iter __ () и iter ():

Под капотом первый шаг, который forдолжен сделать цикл, - это преобразовать наш словарь (итерируемый) dog_foods в объект-итератор .
Объект итератора - это специальный объект, представляющий поток данных, с которыми мы можем работать. 
Для этого он использует встроенную функцию, которая называется iter():

dog_food_iterator = iter(dog_foods)
print(dog_food_iterator)

Этот __iter__()метод определен для всех итераций . Мы даже можем использовать встроенную функцию Python, dir() чтобы показать, 
что наш dog_foodsсловарь (итеративный) имеет определенный вызываемый метод __iter__().
При dog_foods.__iter__()вызове будет получен тот же объект итератора, что и при вызове iter(dog_foods). 
Это означает, что встроенная функция iter()и метод итерации __iter__() могут использоваться как взаимозаменяемые. 

sku_list = [7046538, 8289407, 9056375, 2308597]
print(dir(sku_list))

sku_iterator_object_one = sku_list.__iter__()
print(sku_iterator_object_one)

sku_iterator_object_two = iter(sku_list)
print(sku_iterator_object_two)

// Объекты итератора: __ next __ () и next ():

у объекта итератора есть вызываемый метод __next__(), который извлекает следующее значение итератора.

sku_list = [7046538, 8289407, 9056375, 2308597]
sku_iterator = iter(sku_list)
next_sku = sku_iterator.__next__()
print(next_sku) // 7046538

Вызов next()просто вызывает метод объекта итератора __next__(). Вот тот же сценарий, но с использованием next():

sku_list = [7046538, 8289407, 9056375, 2308597]
sku_iterator = iter(sku_list)
next_sku = next(sku_iterator)
print(next_sku)


Если мы вызовем __next__()в общей сложности 5 раз, что на один больше, чем общее количество SKU в нашем списке, 
мы увидим возникновение StopIterationисключения при последнем __next__() вызове:

sku_list = [7046538, 8289407, 9056375, 2308597]
sku_iterator = iter(sku_list)
for i in range(5):
  next_sku = sku_iterator.__next__()
  print(next_sku)

/

dog_foods = {
  "Great Dane Foods": 4,
  "Min Pip Pup Foods": 10,
  "Pawsome Pup Foods": 8
}

dog_food_iterator = iter(dog_foods)
next_dog_food1 = next(dog_food_iterator)
print(next_dog_food1)
next_dog_food2 = dog_food_iterator.__next__()
print(next_dog_food2)
next_dog_food3 = dog_food_iterator.__next__()
print(next_dog_food3)


// Итераторы и циклы For:

Подводя итог, можно выделить три основных шага:

1) for Цикл будет первым извлечение объекта итератора для dog_foods словаря с использованием iter().

2) Затем next() вызывается на каждой итерации for цикла для получения следующего значения. Это значение устанавливается в for переменную цикла food_brand.

3) На каждой for итерации for цикла выполняется инструкция печати, пока, наконец, цикл не выполнит вызов next(), вызывающий StopIteration исключение. 
Затем for цикл завершается и итерация завершается.

// Пользовательские итераторы I:

Если мы хотим , чтобы создать свой собственный пользовательский класс итератора, мы должны реализовать протокол итератора, означает ,
что мы должны иметь класс , который определяет на минимуме __iter__() и __next__() методы.

class FishInventory:
  def __init__(self, fishList):
      self.available_fish = fishList

Мы не можем просто включать наши пользовательские классы в forциклы и ожидать каких-либо результатов!
Для того, чтобы сделать FishInventory класс Iterable, можно просто определить __iter__() и __next__() методы.

1) __iter__() Метод всегда должен возвращать сам объект итератора. Обычно это достигается возвратом self. 
Он также может включать инициализацию некоторых членов класса.

2) __next__() Метод должен либо вернуть следующее значение доступным или поднять StopIteration исключение. 
Он также может включать в себя любое количество операций.

Мы можем инициализировать член класса в __iter__() вызываемом методе index, который поможет нам отслеживать текущую позицию в self.available_fish списке.
Затем мы определяем __next__() метод. Напомним, что мы можем выполнять операции внутри этого метода, такие как, увеличение членов класса или обход for цикла.

class FishInventory:
  def __init__(self, fishList):
      self.available_fish = fishList
 
  def __iter__(self):
    self.index = 0
    return self
 
  def __next__(self):
    if self.index < len(self.available_fish):
      fish_status = self.available_fish[self.index] + " is available!"
      self.index += 1
      return fish_status
    else:
      raise StopIteration

/

class CustomerCounter:

  def __iter__(self):
    self.count = 0
    return self

  def __next__(self):
    if self.count > 100:
      raise StopIteration
    else:
      self.count += 1
      return self.count

customer_counter = CustomerCounter()

for i in customer_counter:
  print(i)

// Itertools Python: встроенные итераторы:

Python предлагает удобный встроенный модуль с именем itertools, который предоставляет возможность создавать сложные манипуляции с итератором.

Есть три категории итераторов itertool:

1) Бесконечный: бесконечные итераторы будут повторяться бесконечное количество раз. Они не будут вызывать исключение StopIteration,
и для выхода из них потребуется какое-то условие остановки.
2) Конечный: конечные итераторы заканчиваются длиной входной итерируемой-(ых) последовательности-(ей). 
Это означает, что итератор наименьшей длины, используемый в конечном итераторе, завершит итератор.
3) Комбинаторные: комбинаторные итераторы - это итераторы, которые являются комбинационными, в которых математические функции выполняются на входных итерациях.

Мы можем использовать модуль itertools, просто поставив оператор импорта в верхней части модуля следующим образом:
import itertools

// Бесконечный итератор: счет:

Полезным инструментом itertool, который представляет собой бесконечный итератор, является count() itertool. 
Этот бесконечный итератор будет отсчитывать от первого значения до тех пор, пока мы не предоставим какой-либо тип условия остановки.

count(start,[step])


import itertools
 
for i in itertools.count(start=0, step=2):
  print(i)
  if i >= 20:
    break

/

import itertools

max_capacity = 1000
num_bags = 0

for i in itertools.count(start = 13.5, step = 13.5): 
  if i >= max_capacity:
    break
  num_bags += 1

print(num_bags)

// Конечный итератор: цепочка:

Полезным инструментом itertool, который является конечным итератором, является chain() itertool. 
Этот конечный итератор примет одну или несколько итераций и объединит их в один итератор. 

chain(*iterables) <---------------

Входное значение chain() - это одна или несколько итераций одного и того же или различных итерационных типов. 
Например, мы могли бы использовать chain() itertool для объединения списка и набора в один итератор.

import itertools
 
odd = [5, 7, 9]
even = {6, 8, 10}
 
all_numbers = itertools.chain(odd, even)
 
for number in all_numbers:
  print(number)

/

import itertools

great_dane_foods = [2439176, 3174521, 3560031]
min_pin_pup_foods = [6821904, 3302083]
pawsome_pup_foods = [9664865]

all_skus_iterator = itertools.chain(great_dane_foods, min_pin_pup_foods, pawsome_pup_foods)

for i in all_skus_iterator:
  print(i)

// Комбинаторный итератор: комбинации:

Полезным инструментом itertool, который является комбинаторным итератором, является combinations() itertool. 

combinations(iterable, r)

Инструмент combinations() itertool принимает два входа, первый - итерируемый, а второй - значение r, представляющее длину каждого комбинированного кортежа.
Тип возврата combinations() - это итератор, который можно использовать в forцикле или преобразовать в итеративный тип с помощью list() или set().

import itertools
even = [2, 4, 6]
even_combinations = list(itertools.combinations(even, 2))
print(even_combinations)

/

import itertools

collars = ["Red-S","Red-M", "Blue-XS", "Green-L", "Green-XL", "Yellow-M"]

collar_combo_iterator = itertools.combinations(collars, 3)
for i in collar_combo_iterator:
  print(i)

////

import itertools
max_money = 15
options = []


cat_toys = [("laser", 1.99), ("scratcher", 10.99), ("fountain", 5.99), ("catnip", 15.99)]

cat_toy_iterator = iter(cat_toys)

print(next(cat_toy_iterator))
print(next(cat_toy_iterator))
print(next(cat_toy_iterator))
print(next(cat_toy_iterator))

toy_combos = itertools.combinations(cat_toys, 2)

for combo in toy_combos:
    toy1 = combo[0]
    cost_of_toy1 = toy1[1]
    toy2 = combo[1]
    cost_of_toy2 = toy2[1]
    if cost_of_toy1 + cost_of_toy2 <= max_money:
      options.append(combo)
      
print(options)

/

from roster import student_roster
import itertools

class ClassroomOrganizer:
  def __init__(self):
    self.sorted_names = self._sort_alphabetically(student_roster)
    for i in itertools.count(start = 0, step = 1): 
      if i < len(self.sorted_names):
        print(self.sorted_names[i])
      else:
        break
    classroom_iterator = itertools.combinations(self.sorted_names, 2)
    for i in classroom_iterator:
      print(i)

  def _sort_alphabetically(self,students):
    names = []
    for student_info in students:
      name = student_info['name']
      names.append(name)
    return sorted(names)

  def get_students_with_subject(self, subject):
    selected_students = []
    for student in student_roster:
      if student['favorite_subject'] == subject:
        selected_students.append((student['name'], subject))
    return selected_students


Classroom_organizer = ClassroomOrganizer()

// генераторы:

генератор позволяет создавать итераторы без необходимости реализации __iter__()и __next__()

В Python есть два типа генераторов:

Функции генератора
Генератор выражений

Оба они возвращают объект-генератор, который можно перебирать аналогично списку, но, в отличие от списка, 
содержимое объекта-генератора не сохраняется в памяти, что позволяет выполнять сложную и даже бесконечную итерацию данных.

вместо использования return оператора функции генератора используют выражение с именем yield.
любой код, который написан после yield выражения, будет выполняться на следующей итерации итератора. Код, написанный после return оператора, не будет выполняться.


def course_generator():
  yield 'Computer Science'
  yield 'Art'
  yield 'Business'

courses = course_generator()
for course in courses:
    print(course) //output Computer Science, Art, Business
    
yield выражение приостанавливает выполнение функции и сохраняет все локальные переменные, существующие внутри функции.

def class_standing_generator():
  yield 'Freshman'
  yield 'Sophomore'
  yield 'Junior'
  yield 'Senior'

class_standings = class_standing_generator()
for standings in class_standings:
  print(standings)

// next () и StopIteration:

Если yield в функции генератора не найдено дополнительных выражений, это означает, что код завершен и вызывается StopIteration.

def prize_generator():
  student_info = {
    "Joan Stark": 355,
    "Billy Mars": 45,
    "Tori Rivers": 18,
    "Kyle Newman": 25
  }
 
  for student in student_info:
    name = student
    id = student_info[name]
    if id % 3 == 0 and id % 5 == 0:
      yield student + " gets prize C"
    elif id % 3 == 0:
      yield student + " gets prize A"
    elif id % 5 == 0:
      yield student + " gets prize B"

prizes = prize_generator()
print(next(prizes))
print(next(prizes))
print(next(prizes))
print(next(prizes))

/

def student_standing_generator():
  student_standings = ['Freshman','Senior', 'Junior', 'Freshman']
  for student in student_standings:
    if student == 'Freshman':
      yield 500

standing_values = student_standing_generator()
print(next(standing_values))
print(next(standing_values))

// Генератор выражений:

Выражения генератора позволяют четкое однострочное определение и создание итератора.
Выражения генератора напоминают синтаксис списков.

# List comprehension
a_list = [i*i for i in range(4)]
 
# Generator comprehension
a_generator = (i*i for i in range(4))

print(a_list) // [0, 1, 4, 9]
for i in a_generator:
    print(i) // 0, 1, 4, 9

/

def cs_generator():
  for i in range(1,5):
    yield "Computer Science " + str(i)

cs_courses = cs_generator()
for courses in cs_courses:
  print(courses)


cs_generator_exp = ("Computer Science {}".format(i) for i in range(1, 5))
for courses in cs_generator_exp:
  print(courses)
  
// Методы генератора: send ():

.send() метод позволяет нам отправить значение генератору, используя yield выражение. Если вы присваиваете yieldпеременной, аргумент, 
переданный .send() методу, будет присвоен этой переменной. Вызов .send()т акже заставит генератор выполнить итерацию.

def count_generator():
  while True:
    n = yield
    print(n)
 
my_generator = count_generator()
next(my_generator) # 1st Iteration Output: 
next(my_generator) # 2nd Iteration Output: None
my_generator.send(3) # 3rd Iteration Output: 3
next(my_generator) # 4th Iteration Output: None

/

def generator():
  count = 0
  while True:
    n = yield count
    if n is not None:
      count = n
    count += 1
 
my_generator = generator()
print(next(my_generator)) # Output: 0
print(next(my_generator)) # Output: 1
print(my_generator.send(3)) # Output: 4
print(next(my_generator)) # Output: 5

/

MAX_STUDENTS = 50

def get_student_ids():
  student_id = 1
  while student_id <= MAX_STUDENTS:
    n = yield student_id
    if n is not None:
      student_id = n
      continue

    student_id += 1

student_id_generator = get_student_ids()
for i in student_id_generator:
  if i == 1:
    i = student_id_generator.send(25)

  print(i)
  
// Методы генератора: throw ():

Метод генератора throw()предоставляет возможность генерировать исключение внутри генератора из вызывающей точки. 
Это может быть полезно, если нам нужно завершить работу генератора, когда он достигнет определенного значения или соответствует определенному условию.

def generator():
  i = 0
  while True:
    yield i
    i += 1
 
my_generator = generator()
for item in my_generator:
    if item == 3:
        my_generator.throw(ValueError, "Bad value given")

/

def student_counter():
  for i in range(1,5001):
    yield i

student_generator = student_counter()
for student_id in student_generator:
  if student_id > 100:
    student_generator.throw(ValueError, "Invalid student ID")
  print(student_id) // Всего 5000 студ. мы берем ток первые 100, если id > 100, then error

// Методы генератора: close ():

Метод генератора .close() используется для преждевременного отключения генератора. После вызова .close() метода генератор завершает свою работу, 
как и конец файла for loop. Любые дальнейшие попытки повторения вызовут StopIteration исключение.

def generator():
  i = 0
  while True:
    yield i
    i += 1
 
my_generator = generator()
next(my_generator)
next(my_generator)
my_generator.close()
next(my_generator) # raises StopGenerator exception


.close() Метод работает, поднимая GeneratorExit исключение внутри функции генератора. Исключение обычно игнорируется, 
но может быть обработано с помощью try и except.


def generator():
  i = 0
  while True:
    try:
      yield i
    except GeneratorExit:
      print("Early exit, BYE!")
      break
    i += 1
 
my_generator = generator()
for item in my_generator:
  print(item)
  if item == 1:
    my_generator.close()

/

def student_counter():
  for i in range(1,5001):
    yield i

student_generator = student_counter()
for student_id in student_generator:
  print(student_id) // Всего 5000 студ. мы берем ток первые 100, если id > 100,
  if student_id > 99:
    student_generator.close()

// Подключение генераторов: 

В некоторых случаях полезно соединить несколько генераторов в один. Это позволяет нам делегировать операции одного генератора другому подгенератору. 
Подключение генераторов аналогично использованию chain() функции itertools для объединения итераторов в один итератор.
Для подключения генераторов мы используем yield from инструкцию.

def cs_courses():
    yield 'Computer Science'
    yield 'Artificial Intelligence'
 
def art_courses():
    yield 'Intro to Art'
    yield 'Selecting Mediums'
 
 
def all_courses():
    yield from cs_courses()
    yield from art_courses()
 
combined_generator = all_courses()

/

def science_students(x):
  for i in range(1,x+1):
    yield i

def non_science_students(x,y):
  for i in range(x,y+1):
    yield i

def combined_students():
  yield from science_students(5) // Science students with IDs 1-5
  yield from non_science_students(10,15) // Non-science students with IDs 10-15
  yield from non_science_students(25,30) // Non-science students with IDs 25-30
  
student_generator = combined_students()

for student in student_generator:
  print(student)

// Генераторные трубопроводы:

Конвейеры генераторов позволяют нам использовать несколько генераторов для выполнения серии операций в одном выражении. 
Мы можем разбить сложные операции на более мелкие, более управляемые части, которые затем можно объединить в конвейер для достижения желаемого результата.
Для конвейерных генераторов выход одной функции генератора может быть входом другой функции генератора. 
Этот результирующий генератор затем можно использовать в качестве входных данных для другой функции генератора и т.Д.


def number_generator():
  i = 0
  while True:
    yield i
    i += 1
 
def even_number_generator(numbers):
  for n in numbers:
    if n % 2 == 0:
      yield n
 
even_numbers = even_number_generator(number_generator())
 
for e in even_numbers:
  print(e)
  if e == 100:
    break

Когда мы перебираем even_numbers, выводятся только четные числа. В even_number_generator() перебирает все числа , 
используя number_generator(). Когда встречается четное число, это число возвращается функцией even_number_generator().


def course_generator():
    yield ("Computer Science", 5)
    yield ("Art", 10)
    yield ("Business", 15)
    
def add_five_students(courses):
  for course, num in courses:
    yield(course, num + 5)

increased_courses = add_five_students(course_generator())

for i in increased_courses:
  print(i)

/

def summa():
    yield 'Summa Cum Laude'

def magna():
    yield 'Magna Cum Laude' 

def cum_laude():
    yield 'Cum Laude'

def honors_generator(gpas):
  for gpa in gpas:
    if gpa > 3.9:
      yield from summa()
    elif gpa > 3.7:
      yield from magna()
    elif gpa > 3.5:
      yield from cum_laude()


def graduation_countdown(days):
  while days > 0:
    days_left = yield days
    if days_left != None:
      days = days_left
    else:
      days -= 1


days = 25
countdown_generator = (day for day in range(days, -1,-1))
grad_days = graduation_countdown(days)
for day in grad_days:
  if day == 15:
    grad_days.send(10)
  elif day == 3:
    grad_days.close()
  print("Days Left: " + str(day))


days = 25
gpas = [3.2, 4.0, 3.6, 2.9]
honors = honors_generator(gpas)
for honor_label in honors:
  print(honor_label)
  
// наборы Python:

В Python набор - это группа элементов, которые неупорядочены и не содержат дубликатов. Хотя может показаться, что полезность этой структуры данных ограничена, 
на самом деле она может быть очень полезной для организации элементов и выполнения математических вычислений.
есть также неизменная версия набора, называемая Frozenset. Frozenset ведет себя так же, как обычный набор, но не включает методов, 
которые каким-либо образом модифицируют Frozenset.

# Creating a set with curly braces
music_genres = {'country', 'punk', 'rap', 'techno', 'pop', 'latin'}
 
# Creating a set from a list using set()
music_genres_2 = set(['country', 'punk', 'rap', 'techno', 'pop', 'latin'])

# Creating a set with curly braces
music_genres_3 = set(['country', 'punk', 'rap', 'pop', 'pop', 'pop'])
print(music_genres_3) // {'country', 'punk', 'pop', 'rap'}

# Creating an empty set using the set() constructor
# Doing set = {} will define a dictionary rather than a set.  
 
empty_genres = set()

Наконец, аналогично составлению списков, мы можем создавать наборы, используя понимание множества и набор данных (например, список):

items = ['country', 'punk', 'rap', 'techno', 'pop', 'latin']
 
music_genres = {category for category in items if category[0] == 'p'}
print(music_genres) // {'punk', 'pop'}

/

genre_results = ['rap', 'classical', 'rock', 'rock', 'country', 'rap', 'rock', 'latin', 'country', 'k-pop', 'pop', 'rap', 'rock', 'k-pop',  'rap', 'k-pop', 'rock', 'rap', 'latin', 'pop', 'pop', 'classical', 'pop', 'country', 'rock', 'classical', 'country', 'pop', 'rap', 'latin']

survey_genres = set(genre_results)
print(survey_genres)

survey_abbreviated = {genre[0:3] for genre in genre_results}
print(survey_abbreviated)

// Создание Frozenset:

В отличие от обычного set, вы можете создать только frozenset конструктор. 
Помните, что использование frozenset средства означает, что вы не можете изменять элементы внутри него.

# Creating a frozenset from a list
frozen_music_genres = frozenset(['country', 'punk', 'rap', 'techno', 'pop', 'latin'])

Мы также можем создать пустой frozenset:
empty_frozen_music_genres = frozenset()

top_genres = ['rap', 'rock', 'pop']
frozen_top_genres = frozenset(top_genres)
print(frozen_top_genres)

// Добавление в набор:

Есть два разных способа добавить элементы в набор:

1) .add() Метод может добавить один элемент к set:

# Create a set to hold the song tags
song_tags = {'country', 'folk', 'acoustic'}
 
# Add a new tag to the set and try to add a duplicate.
song_tags.add('guitar')
song_tags.add('country')
 
print(song_tags) // {'country', 'acoustic', 'guitar', 'folk'}


2) .update() Метод может добавить несколько элементов:

# Create a set to hold the song tags
song_tags = {'country', 'folk', 'acoustic'}
 
# Add more tags using a hashable object (such as a list of elements)
other_tags = ['live', 'blues', 'acoustic']
song_tags.update(other_tags)
 
print(song_tags) // {'acoustic', 'folk', 'country', 'live', 'blues'}

/

song_data = {'Retro Words': ['pop', 'warm', 'happy', 'electric']}

user_tag_1 = 'warm'
user_tag_2 = 'exciting'
user_tag_3 = 'electric'

tag_set = set(song_data['Retro Words'])
tag_set.update([user_tag_1, user_tag_2, user_tag_3])

song_data = {'Retro Words': tag_set}
print(song_data)

// Удаление из набора:

Есть два метода удаления определенных элементов из set:

1) В .remove() поисках метода для элемента в пределах set и удаляет его , если он существует, в противном случае KeyError выбрасываются.

# Given a list of song tags
song_tags = {'guitar', 'acoustic', 'folk', 'country', 'live', 'blues'}
 
# Remove an existing element
song_tags.remove('folk')
print(song_tags)
 
# Try removing a non-existent element
song_tags.remove('fiddle') // this sentence give us an error

2) .discard() Метод работает так же, но не бросает исключение, если элемент отсутствует:

# Given a list of song tags
song_tags = {'guitar', 'acoustic', 'folk', 'country', 'live', 'blues'}
 
# Try removing a non-existent element but with the discard method
song_tags.discard('guitar')
print(song_tags)
 
# Try removing a non-existent element but with the discard method
song_tags.discard('fiddle')
print(song_tags)

/

song_data_users = {'Retro Words': ['pop', 'onion', 'warm', 'helloworld', 'happy', 'spam', 'electric']}

tag_set = set(song_data_users['Retro Words'])
tag_set.discard('onion')
tag_set.discard('helloworld')
tag_set.discard('spam')

song_data_users = {'Retro Words': tag_set}
print(song_data_users)

// Поиск элементов в наборе:

В Python set и к frozenset элементам нельзя получить доступ по определенному индексу. Это связано с тем, что оба контейнера неупорядочены и не имеют индексов. 
Однако, как и большинство других контейнеров Python, мы можем использовать in ключевое слово, чтобы проверить, находится ли элемент в set или frozenset.

# Given a list of song tags
song_tags = {'guitar', 'acoustic', 'folk', 'country', 'live', 'blues'}
# Print the result of testing whether 'country' is in the set of tags or not
print('country' in song_tags) // True

song_tags = {'guitar', 'acoustic', 'folk', 'country', 'live', 'blues'}
frozen_tags = frozenset(song_tags)
print('rock' in frozen_tags) // False

/

allowed_tags = ['pop', 'hip-hop', 'rap', 'dance', 'electronic', 'latin', 'indie', 'alternative rock', 'classical', 'k-pop', 'country', 'rock', 'metal', 'jazz', 'exciting', 'sad', 'happy', 'upbeat', 'party', 'synth', 'rhythmic', 'emotional', 'relationship', 'warm', 'guitar', 'fiddle', 'romance', 'chill', 'swing']

song_data_users = {'Retro Words': ['pop', 'explosion', 'hammer', 'bomb', 'warm', 'due', 'writer', 'happy', 'horrible', 'electric', 'mushroom', 'shed']}

tag_set = set(song_data_users['Retro Words'])
bad_tags = []
for tag in tag_set:
    if tag not in allowed_tags:
        bad_tags.append(tag)

for tag in bad_tags:
    tag_set.remove(tag)
print(tag_set)

song_data_users['Retro Words'] = tag_set
print(song_data_users)






























