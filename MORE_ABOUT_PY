////////// Аргументы функций:
Позиционные аргументы
def print_name(first_name, last_name): 
  print(first_name, last_name)
 
print_name('Jiho', 'Baggins')


Аргументы ключевых слов
def print_name(first_name, last_name): 
  print(first_name, last_name)
 
print_name(last_name='Baggins', first_name='Jiho')

Аргументы по умолчанию
def print_name(first_name='Jiho', last_name='Baggins'): 
  print(first_name, last_name)
 
print_name()


tables = {
  1: ['Jiho', False],
  2: [],
  3: [],
  4: [],
  5: [],
  6: [],
  7: [],
}
print(tables)


def assign_table(table_number, name, vip_status=False): 
  tables[table_number] =  [name, vip_status]

assign_table(6, 'Yoni', False)
assign_table(table_number = 3, name = 'Martha', vip_status = True)
assign_table(4, 'Karla')
print(tables)

///////////// Переменное количество аргументов: *args

def my_function(*args):
  print(args) // ('Arg1', 245, False)
  
my_function('Arg1', 245, False)
//

def print_order(*order_items):
  print(order_items) // ('Orange Juice', 'Apple Juice', 'Scrambled Eggs', 'Pancakes')

print_order('Orange Juice', 'Apple Juice', 'Scrambled Eggs', 'Pancakes')
//

def shout_strings(*args):
  for argument in args:
    print(argument.upper()) // WORKING ON, LEARNING, ARGUMENT UNPACKING!
 
shout_strings('Working on', 'learning', 'argument unpacking!') 


def truncate_sentences(length, *sentences):
  for sentence in sentences:
    print(sentence[:length]) // What's g, Looks li
 
truncate_sentences(8, "What's going on here", "Looks like we've been cut off")

//
tables = {
  1: {
    'name': 'Jiho',
    'vip_status': False,
    'order': 'Orange Juice, Apple Juice'
  },
  2: {},
  3: {},
  4: {},
  5: {},
  6: {},
  7: {},
}
print(tables)

def assign_table(table_number, name, vip_status=False): 
  tables[table_number]['name'] = name
  tables[table_number]['vip_status'] = vip_status
  tables[table_number]['order'] = ''

# Write your code below: 
def assign_and_print_order(table_number, *order_items):
  tables[table_number]['order'] = order_items
  for order in order_items:
    print(order)

assign_table(2, 'Arwa', True)

assign_and_print_order(2, 'Steak', 'Seabass', 'Wine Bottle')
print(tables)

////////// Переменное количество аргументов: ** kwargs

def arbitrary_keyword_args(**kwargs):
  print(type(kwargs))
  print(kwargs)
  print(kwargs.get('anything_goes'))
 
arbitrary_keyword_args(this_arg='wowzers', anything_goes=101)
// output 
<class 'dict'>
{'this_arg': 'wowzers', 'anything_goes': 101}
101


tables = {
  1: {
    'name': 'Chioma',
    'vip_status': False,
    'order': {
      'drinks': 'Orange Juice, Apple Juice',
      'food_items': 'Pancakes'
    }
  },
  2: {},
  3: {},
  4: {},
  5: {},
  6: {},
  7: {},
}
print(tables)

def assign_food_items(**order_items):
  food = order_items.get('food')
  drinks = order_items.get('drinks')
  print(order_items)
  print(food)
  print(drinks)

assign_food_items(food='Pancakes, Poached Egg', drinks='Water')

//

def print_data(**data):
  for arg in data.values():
    print(arg) // arg1, True, 100
 
print_data(a='arg1', b=True, c=100)


def print_data(positional_arg, **data):
  print(positional_arg)
  for arg in data.values():
    print(arg) // position 1, arg1, True, 100
 
print_data('position 1', a='arg1', b=True, c=100)


tables = {
  1: {
    'name': 'Chioma',
    'vip_status': False,
    'order': {
      'drinks': 'Orange Juice, Apple Juice',
      'food_items': 'Pancakes'
    }
  },
  2: {},
  3: {},
  4: {},
  5: {},
  6: {},
  7: {},
}

def assign_table(table_number, name, vip_status=False): 
  tables[table_number]['name'] = name
  tables[table_number]['vip_status'] = vip_status
  tables[table_number]['order'] = {}

assign_table(2, 'Douglas', True)
print('--- tables with Douglas --- \n', tables)

def assign_food_items(table_number, **order_items):
  food = order_items.get('food')
  drinks = order_items.get('drinks')
  tables[table_number]['order']['food_items'] = food
  tables[table_number]['order']['drinks'] = drinks

print('\n --- tables after update --- \n')

assign_food_items(2, food = 'Seabass, Gnocchi, Pizza', drinks = 'Margarita, Water')
print(tables)

//

def print_animals(animal1, animal2, *args, animal4, **kwargs):
  print(animal1, animal2)
  print(args)
  print(animal4)
  print(kwargs)

print_animals('Snake', 'Fish', 'Guinea Pig', 'Owl', animal4='Cat', animal5='Dog') //output Snake Fish, ('Guinea Pig', 'Owl'), Cat, {'animal5': 'Dog'}

def single_prix_fixe_order(appetizer, *entrees, sides, **dessert_scoops):
  print(appetizer)
  print(entrees)
  print(sides)
  print(dessert_scoops)

single_prix_fixe_order('Baby Beets', 'Salmon', 'Scallops', sides = 'Mashed Potatoes', iceream_scoop_1 = 'Vanilla', iceream_scoop_2 = 'Cookies and Cream')

///////// Распаковка вызовов функций:

numbers  = {'num1': 3, 'num2': 6, 'num3': 9}
def sum(num1, num2, num3):
  print(num1 + num2 + num3) // 18
 
sum(**numbers)


start_and_stop = [3, 6]
range_values = range(*start_and_stop)
print(list(range_values)) // [3, 4, 5]


 a, *b, c = [3, 6, 9, 12, 15]
 print(b) // [6, 9, 12]


my_tuple = (3, 6, 9)
merged_tuple = (0, *my_tuple, 12)
print(merged_tuple) // (0, 3, 6, 9, 12)


num_collection = [3, 6, 9]
def power_two(*nums): 
  for num in nums:
    print(num**2) // 9 36 81
 
power_two(*num_collection)


def calculate_price_per_person(total, tip, split):
  total_tip = total * (tip/100)
  split_price = (total + total_tip) / split
  print(split_price)

table_7_total = [534.50, 20.0, 5]

calculate_price_per_person(*table_7_total)

///////////// Введение в имена и пространства имен:

// Встроенное пространство имен

print(dir(__builtins__))

// Глобальное пространство имен

print(globals())

// Локальное пространство имен 

print(locals())

// Включение пространства имен

global_variable = 'global'
 
def outer_function():
  outer_value = "outer"
 
  def inner_function():
    inner_value = "inner"

    def inner_nested_function():
      nested_value = 'nested'
    inner_nested_function()
    print(locals())
  inner_function()
 
outer_function()

// Локальный охват

def painting(paint_colors, picture):
  painting_statement = "To paint the " + picture + " we need the following colors: "
  print(painting_statement)
  for color in paint_colors:
      print(color)

painting(['Orange', 'White', 'Green'], 'Indian Flag')

// Охватывающая / нелокальная область видимости

def calc_paint_amount(width, height):
  square_feet = width * height
  def calc_gallons():
      return square_feet / 400

  return calc_gallons()


print('Number of paint gallons needed: ')
print(str(calc_paint_amount(30,20)))

// Изменение поведения области действия

walls = [(20, 9), (25, 9), (20, 9), (25, 9)]


def calc_paint_amount(wall_measurements):

  square_feet = 0

  def calc_square_feet():
    
    for width, height in wall_measurements:
      nonlocal square_feet <----------------------------
      square_feet += width * height

  def calc_gallons():
    return square_feet / 400

  calc_square_feet()

  return calc_gallons()


print('Number of paint gallons needed: ')
print(str(calc_paint_amount(walls)))

// Глобальный масштаб

paint_gallons_available = {
    'red': 50,
    'blue': 72,
    'green': 99,
    'yellow': 33
}
def print_available(color):

  print('There are ' + str(paint_gallons_available[color]) + ' gallons available of ' + color + ' paint.')


def print_all_colors_available():
  for color in paint_gallons_available:
    print(color)

print_available('red')
print_all_colors_available()

// Изменение поведения области действия

global_var = 10
def some_function():
  global_var = 20
some_function()
 
print(global_var) // 10

global_var = 10
def some_function():
  global global_var
  global_var = 20
some_function()
 
print(global_var) // 20


def print_available(color):
  global paint_gallons_available
  paint_gallons_available = {
    'red': 50,
    'blue': 72,
    'green': 99,
    'yellow': 33
  }
  print('There are ' + str(paint_gallons_available[color]) + ' gallons available of ' + color + ' paint.')


print_available('red')
for color in paint_gallons_available:
  print(color)

// Разрешение области действия: правило LEGB

color = 'green'

def change_color(new_color):
  global color
  # Checkpoint #2
  to_update = new_color
  
  def disp_color():
    print('The original color was: ' + color)

  disp_color()
  # Checkpoint #3
  color = to_update
  print('The new color is: ' + color)

change_color('blue')

// 

def add_two(my_input):
  return my_input + 2

OR WE CAN USE THIS: 

add_two = lambda my_input: my_input + 2

print(add_two(3))
print(add_two(100))
print(add_two(-2)) // output 5, 102, 0


check_if_A_grade = lambda grade: 'Got an A!' if grade >= 90 else 'Did not get an A.'

// Введение в функции высшего порядка:

# Here, we assign a function to a variable
uppercase = str.upper 
 
# And then call it 
big_pie = uppercase("pumpkinpie")


// Функции как аргументы:

def total_bill(func, value):
  total = func(value)
  return total

def add_tax(total):
  tax = total * 0.06
  new_total = total + tax
  return new_total
 
total_bill(add_tax, 100) // output 106.0


def total_bill(func, value):
  total = func(value)
  return ("The total amount owed is $" + "{:.2f}".format(total) + ". Thank you! :)")
 
 
print(total_bill(add_tax, 100)) // 'The total amount owed is $106.00. Thank you! :)'

// Функции как аргументы - итерация:

bills = [115, 120, 42]
 
new_bills = []
 
for i in range(len(bills)):
  total = add_tax(bills[i])
  new_bills.append("Total amount owed is $" + "{:.2f}".format(total) + ". Thank you! :)")
 
print(new_bills) // output ['Total amount owed is $121.90. Thank you! :)', 'Total amount owed is $127.20. Thank you! :)', 'Total amount owed is $44.52. Thank you! :)']


def total_bills(func, list):
  # This list will store all the new bill values
  new_bills = []
 
  # This loop will iterate through our bills
  for i in range(len(list)):
 
    # Here we apply the function to each element of the list!
    total = func(list[i])
    new_bills.append("Total amount owed is $" + "{:.2f}".format(total) + ". Thank you! :)")
 
  return new_bills

bills = [115, 120, 42]
 
bills_w_tax = total_bills(add_tax, bills)
 
print(bills_w_tax) ['Total amount owed is $121.90. Thank you! :)', 'Total amount owed is $127.20. Thank you! :)', 'Total amount owed is $44.52. Thank you! :)']

// Функции как возвращаемые значения:

def make_box_volume_function(height):
    # defines and returns a function that takes two numeric arguments,        
    # length &  width, and returns the volume given the input height
    def volume(length, width):
        return length*width*height
 
    return volume
 
box_volume_height15 = make_box_volume_function(15)
 
print(box_volume_height15(3,2)) // 90

// map():

Функция map()высшего порядка имеет следующую базовую структуру:
returned_map_object = map(function, iterable)

def double(x):
 return x*2
 
int_list = [3, 6, 9]
 
doubled = map(double, int_list)
 
print(doubled) // <map at 0x7f1ca0f58090>
OR WE CAN USE THIS TO HAVE NORMAL OUTPUT: print(list(doubled)) // [6, 12, 18]

also we can create that function:

doubled = map(lambda input: input*2, int_list)
print(list(doubled)) // [6, 12, 18]

grade_list = [3.5, 3.7, 2.6, 95, 87]

grades_100scale = map(lambda grade: grade* 25 if grade < 25 else grade, grade_list)

updated_grade_list = list(grades_100scale)
print(updated_grade_list)

// filter():

функция принимает в качестве аргументов функцию и итерацию. Как следует из названия, цель filter() функции - «отфильтровать» значения из итерируемого объекта.

names = ["margarita", "Linda", "Masako", "Maki", "Angela"]
M_names = filter(lambda name: name[0] == "M" or name[0] == "m", names) 

print(list(M_names)) // ['margarita', 'Masako', 'Maki']
/
books = [["Burgess", 1985],
 ["Orwell", "Nineteen Eighty-four"],
  ["Murakami", "1Q85"],
   ["Orwell", 1984],
    ["Burgess", "Nineteen Eighty-five"],
     ["Murakami", 1985]]

string_titles = filter(lambda book: type(book[1]) != int, books)
string_titles_list = list(string_titles)
print(string_titles_list)

// reduce():

В отличие от map() и filter() функций, которые всегда доступны, то reduce() функция должна быть импортированы из functools модуля , чтобы использовать его.
Вместо того, чтобы возвращать reduce объект, как можно было бы ожидать после изучения map() и filter(), reduce() возвращает единственное значение. 

from functools import reduce
int_list = [3, 6, 9, 12]
reduced_int_list = reduce(lambda x,y: x*y, int_list)

print(reduced_int_list) // 1944

//////////////////////// OOP

// Введение в объектно-ориентированное программирование

class Employee:
  new_id = 1
  def __init__(self):
    self.id = Employee.new_id
    Employee.new_id += 1

  def say_id(self):
    print('My id is ' + str(self.id))


e1 = Employee()
e1.say_id()
e2 = Employee()
e2.say_id()

// Столб ООП: наследование:

class Animal: 
  def eat(self): 
    print("Nom Nom Nom...eating food!")

class Dog(Animal):
  def bark(self):
    print('Bark!')
 
class Cat(Animal):
  def meow(self):
    print('Meow!')

fluffy = Dog()
zoomie = Cat()
 
fluffy.eat() # Nom Nom Nom...eating food!
zoomie.eat() # Nom Nom Nom...eating food!
/ 
class Employee():
  new_id = 1
  def __init__(self):
    self.id = Employee.new_id
    Employee.new_id += 1

  def say_id(self):
    print("My id is {}.".format(self.id))

class Admin(Employee):
  pass

e1 = Employee()
e2 = Employee()
e3 = Admin()

e3.say_id() // My id is 3.

// Переопределение методов:

class Animal:
  def __init__(self, name):
    self.name = name
 
  def make_noise(self):
    print("{} says, Grrrr".format(self.name))
 
pet1 = Animal("Rex")
pet1.make_noise() # Rex says, Grrrr
/
class Cat(Animal):
 
  def make_noise(self):
    print("{} says, Meow!".format(self.name))
 
pet2 = Cat("Maisy")
pet2.make_noise() # Maisy says, Meow!
/
class Employee():
  new_id = 1
  def __init__(self):
    self.id = Employee.new_id
    Employee.new_id += 1

  def say_id(self):
    print("My id is {}.".format(self.id))

class Admin(Employee):
  # Write your code below
  def say_id(self):
    print("I am an Admin")

e1 = Employee()
e2 = Employee()
e3 = Admin()
e3.say_id() // I am an Admin 

//  super():

class Animal:
  def __init__(self, name, sound="Grrrr"):
    self.name = name
    self.sound = sound
 
  def make_noise(self):
    print("{} says, {}".format(self.name, self.sound))
 
class Cat(Animal):
  def __init__(self, name):
    super().__init__(name, "Meow!") <----------------------
 
pet_cat = Cat("Rachel")
pet_cat.make_noise() # Rachel says, Meow!
/
class Employee():
  new_id = 1
  def __init__(self):
    self.id = Employee.new_id
    Employee.new_id += 1

  def say_id(self):
    print("My id is {}.".format(self.id))

class Admin(Employee):
  def say_id(self):
    super().say_id()
    print("I am an admin.")

e1 = Employee()
e2 = Employee()
e3 = Admin()
e3.say_id() // My id is 3., I am an admin.

// Множественное наследование:

class Animal:
  def __init__(self, name):
    self.name = name
 
  def say_hi(self):
    print("{} says, Hi!".format(self.name))
 
class Cat(Animal):
  pass
 
class Angry_Cat(Cat):
  pass
 
my_pet = Angry_Cat("Mr. Cranky")
my_pet.say_hi() # Mr. Cranky says, Hi!
/
class Employee():
  new_id = 1
  def __init__(self):
    self.id = Employee.new_id
    Employee.new_id += 1

  def say_id(self):
    print("My id is {}.".format(self.id))

class Admin(Employee):
  def say_id(self):
    super().say_id()
    print("I am an admin.")

# Write your code below
class Manager(Admin):
  def say_id(self):
    print('I am in charge')
    super().say_id()

e1 = Employee()
e2 = Employee()
e3 = Admin()
e4 = Manager()
e4.say_id() // I am in charge, My id is 4., I am an admin.
/
class Animal:
  def __init__(self, name):
    self.name = name
 
class Dog(Animal):
  def action(self):
    print("{} wags tail. Awwww".format(self.name))
 
class Wolf(Animal):
  def action(self):
    print("{} bites. OUCH!".format(self.name))
 
class Hybrid(Dog, Wolf):
  def action(self):
    super().action()
    Wolf.action(self)
 
my_pet = Hybrid("Fluffy")
my_pet.action() # Fluffy wags tail. Awwww
                # Fluffy bites. OUCH!
                
/
class Employee():
  new_id = 1
  def __init__(self):
    self.id = Employee.new_id
    Employee.new_id += 1

  def say_id(self):
    print("My id is {}.".format(self.id))

class User:
  def __init__(self, username, role="Customer"):
    self.username = username
    self.role = role

  def say_user_info(self):
    print("My username is {}".format(self.username))
    print("My role is {}".format(self.role))

# Write your code below
class Admin(Employee, User):
  def __init__(self):
    super().__init__()
    User.__init__(self, self.id, "Admin")

  def say_id(self):
    super().say_id()
    print("I am an admin.")

e1 = Employee()
e2 = Employee()
e3 = Admin()
e3.say_user_info() // My username is 3, My role is Admin

// Столб ООП: полиморфизм:

class Animal:
  def __init__(self, name):
    self.name = name
 
  def make_noise(self):
    print("{} says, Grrrr".format(self.name))
 
class Cat(Animal):
 
  def make_noise(self):
    print("{} says, Meow!".format(self.name))
 
class Robot:
 
  def make_noise(self):
    print("beep.boop...BEEEEP!!!")

an_animal = Animal("Bear")
my_pet = Cat("Maisy")
my_vacuum = Robot()
objects = [an_animal, my_pet, my_vacuum]
for o in objects:
  o.make_noise()
 
# OUTPUT
# "Bear says, Grrrr"
# "Maisy says, Meow!"
# "beep.boop...BEEEEP!!!"
/
class Employee():
  new_id = 1
  def __init__(self):
    self.id = Employee.new_id
    Employee.new_id += 1

  def say_id(self):
    print("My id is {}.".format(self.id))

class Admin(Employee):
  def say_id(self):
    super().say_id()
    print("I am an admin.")

class Manager(Admin):
  def say_id(self):
    super().say_id()
    print("I am in charge!")

meeting = [Employee(), Admin(), Manager()]

for m in meeting:
  m.say_id()

// Методы Дандера:

# For an int and an int, + returns an int
2 + 4 == 6
 
# For a string and a string, + returns a string
"Is this " + "addition?" == "Is this addition?"
 
# For a list and a list, + returns a list
[1, 2] + [3, 4] == [1, 2, 3, 4]

/

class Animal:
  def __init__(self, name):
    self.name = name
 
  def __add__(self, another_animal):
    return Animal(self.name + another_animal.name)
 
a1 = Animal("Horse")
a2 = Animal("Penguin")
a3 = a1 + a2
print(a1) # Horse
print(a2) # Penguin
print(a3) # HorsePenguin

/

class Employee():
  new_id = 1
  def __init__(self):
    self.id = Employee.new_id
    Employee.new_id += 1

class Meeting:
  def __init__(self):
    self.attendees = []
  
  def __add__(self, employee):
    print("ID {} added.".format(employee.id))
    self.attendees.append(employee)

  # Write your code
  def __len__(self):
    return len(self.attendees)
    
e1 = Employee()
e2 = Employee()
e3 = Employee()
m1 = Meeting()

m1 + e1
m1 + e2
m1 + e3
print(len(m1)) // ID 1 added., ID 2 added., ID 3 added., 3

// Столб ООП: Абстракция:

from abc import ABC, abstractmethod
 
class Animal(ABC):
  def __init__(self, name):
    self.name = name
 
  @abstractmethod
  def make_noise(self):
    pass
 
class Cat(Animal):
  def make_noise(self):
    print("{} says, Meow!".format(self.name))
 
class Dog(Animal):
  def make_noise(self):
    print("{} says, Woof!".format(self.name))
 
kitty = Cat("Maisy")
doggy = Dog("Amber")
kitty.make_noise() # "Maisy says, Meow!"
doggy.make_noise() # "Amber says, Woof!"

IF WE WRITE SMTH LIKE THAT: 
an_animal = Animal("Scruffy")
# TypeError: Can't instantiate abstract class Animal with abstract method make_noise

/

from abc import ABC, abstractmethod

class AbstractEmployee(ABC):
  new_id = 1
  def __init__(self):
    self.id = AbstractEmployee.new_id
    AbstractEmployee.new_id += 1

  @abstractmethod
  def say_id(self):
    pass

# Write your code below
class Employee(AbstractEmployee):
    def say_id(self):
      print("The id is {}".format(self.id))


e1 = Employee()
e1.say_id()

// Столб ООП: инкапсуляция:

class Employee():
    def __init__(self):
        self.id = None // Общественные
        self._id = '2-nd from end' // Защищено
        self.__id = 'aboba' // Частный

e = Employee()
print(dir(e))

// Геттеры, сеттеры и удалители:

class Animal:
  def __init__(self, name):
    self._name = name
    self._age = None
 
  def get_age(self):
    return self._age
 
  def set_age(self, new_age):
    if isinstance(new_age, int):
      self._age = new_age
    else:
      raise TypeError
 
  def delete_age(self):
    print("_age Deleted")
    del self._age

a = Animal("Rufus")
print(a.get_age()) # None
 
a.set_age(10)
print(a.get_age()) # 10
 
a.set_age("Ten") # Raises a TypeError
 
a.delete_age() # "_age Deleted"
print(a.get_age()) # Raises a AttributeError

/

class Employee():
  new_id = 1
  def __init__(self, name=None):
    self.id = Employee.new_id
    Employee.new_id += 1
    self._name = name

  # Write your code below
  def get_name(self):
    return self._name
  
  def set_name(self, new_name):
    self._name = new_name

  def del_name(self):
    del self._name


e1 = Employee("Maisy")
e2 = Employee()



e1 = Employee("Maisy")
e2 = Employee()
print(e1.get_name())

e2.set_name("Fluffy")
print(e2.get_name())

e2.del_name()
print(e2.get_name())

// Декоратор @property:

Начнем с рассмотрения примера класса, вызываемого Boxс одним вызываемым атрибутом weight. 
В этом случае weightэто будет частный атрибут с геттером и сеттером ( getWeight()и setWeight()).

class Box:
  def __init__(self, weight):
    self.__weight = weight
 
  def getWeight(self):
    return self.__weight
 
  def setWeight(self, weight):
    if weight >= 0:
      self.__weight = weight
      
Мы хотим следовать лучшим практикам, обозначая вес как частный атрибут, используя __(dunder) нотацию.
box = Box(10)
 
box.setWeight(-5) 
print(box.getWeight()) // 10
 
box.setWeight(5)
print(box.getWeight()) // 5

// Встроенная функция property ():

Python встроенных property()функций принимает четыре необязательных аргумента: fget, fset, fdel, и doc. 
Первые три представляют методы получения, установки и удаления соответственно, а последний - это строка документации для атрибута.

class Box:
  def __init__(self, weight):
    self.__weight = weight
 
  def getWeight(self):
    return self.__weight
 
  def setWeight(self, weight):
    if weight >= 0:
      self.__weight = weight
 
  def delWeight(self):
    del self.__weight
 
  weight = property(getWeight, setWeight, delWeight, "Docstring for the 'weight' property")

box = Box(10)
print(box.weight) #this calls .getWeight()
box.weight = 5 #this called .setWeight()
del box.weight #this calls .delWeight()
box.weight = -5 #box.__weight is unchanged 

// @property Decorator:

class Box:
 def __init__(self, weight):
   self.__weight = weight
 
 @property
 def weight(self):
   """Docstring for the 'weight' property"""
   return self.__weight
 
 
 @weight.setter
 def weight(self, weight):
   if weight >= 0:
     self.__weight = weight
 
 @weight.deleter
 def weight(self):
   del self.__weight

Это эквивалент выполнения:
weight = property(getWeight, setWeight, delWeight,  "Docstring for the 'weight' property")

И, таким образом, дает нам то же синтаксическое преимущество, что и раньше:
box = Box(10)
box.weight = 5
del box.weight


// Введение в исключения

Исключения - это ошибки времени выполнения, потому что они возникают во время выполнения программы, 
только когда достигается неправильный код (код, вызывающий ошибку)

// Встроенные исключения

ольшинство исключений наследуются непосредственно от вызываемого класса Exception; 
однако все они прямо или косвенно являются производными от BaseExceptionкласса. 
Мы можем исследовать базовые классы, используя __bases__атрибут для любого конкретного исключения:

print(NameError.__bases__) // <class 'Exception'>

Мы можем даже назвать __bases__на Exceptionклассе , чтобы увидеть его происхождение:
print(Exception.__bases__) // <class 'BaseException'>


sale_instruments = ['Violin', 'Conga', 'Clavinet']

print('The following ' + str(len(sale_instruments)) + ' instruments are on sale:')
print(sale_instruments[0])
print(sale_instruments[1])
print(sale_instruments[2])
print(TypeError.__bases__)

// Вызов исключений:

Мы можем создать исключение в любое время, используя raise ключевое слово

Один из способов использования raise ключевого слова - связать его с определенным именем класса исключения. 
Мы можем либо вызвать класс сам по себе, либо вызвать конструктор и предоставить конкретное сообщение об ошибке.

raise NameError
# or 
raise NameError('Custom Message')

/

def open_register(employee_status):
  if employee_status == 'Authorized':
    print('Successfully opened cash register')
  else:
    # Alternatives: raise TypeError() or TypeError('Message')
    raise TypeError

OR

def open_register(employee_status):
  if employee_status == 'Authorized':
    print('Successfully opened cash register')
  else:
    raise Exception('Employee does not have access!')

/

instrument_catalog = {
  'Marimba': 1999,
  'Kora': 499,
  'Flute': 899
}

def print_instrument_price(instrument):
  # Write your code below:
  if instrument in instrument_catalog:
    print('The price of a ' + instrument + ' is ' + str(instrument_catalog[instrument]))
  else: raise KeyError(instrument + ' is not found in instrument catalog!')
print_instrument_price('Marimba')
print_instrument_price('Flute')
print_instrument_price('Piano')

// try/ except:

colors = {
    'red': '#FF0000',
    'blue': '#0000FF',
    'yellow': '#FFFF00',
}
 
for color in ('red', 'green', 'yellow'):
  try:
    print('The hex value of ' + color + ' is ' + colors[color])
  except:
    print('An exception occurred! Color does not exist.')
  print('Loop continues...')

// output
The hex value of red is #FF0000
Loop continues...
An exception occurred! Color does not exist.
Loop continues...
The hex value of yellow is #FFFF00
Loop continues...

/ 

staff = {
  'Austin': {
      'floor managers': 1,
      'sales associates': 5
  },
  'Melbourne': {
      'floor managers': 0,
      'sales associates': 8
  },
  'Beijing': {
      'floor managers': 2,
      'sales associates': 5
  },
}

def print_staff_report(location, staff_dict):
  managers = staff_dict['floor managers']
  sales_people = staff_dict['sales associates']
  ratio = sales_people / managers
  print('Instrument World ' + location + ' has:')
  print(str(sales_people) + ' sales employees')
  print(str(managers) + ' floor managers')
  print('The ratio of sales people to managers is ' + str(ratio))
  print()

for location, staff in staff.items():

  try:
    print_staff_report(location, staff)
  except:
    print('Could not print sales report for ' + location)

// Выявление особых исключений:

try:
    print(undefined_var)
except NameError:
    print('We hit a NameError')

В этом случае except блок выполняется, только если NameErrorвстречается (в try блоке), а не какое-либо исключение. 
Also we can use AS:

try:
    print(undefined_var)
except NameError as errorObject: <-----
    print('We hit a NameError')
    print(errorObject) // We hit a NameError, name 'undefined_var' is not defined

/

staff = {
  'Austin': {
    'floor managers': 1,
    'sales associates': 5
  },
  'Melbourne': {
    'floor managers': 0,
    'sales associates': 8
  },
  'Beijing': {
    'floor managers': 2,
    'sales associates': 5
  },
}

def print_staff_report(location, staff_dict):
  managers = staff_dict['floor managers']
  sales_people = staff_dict['sales associates']
  ratio = sales_people / managers
  print('Instrument World ' + location + ' has:')
  print(str(sales_people) + ' sales employees')
  print(str(managers) + ' floor managers')
  print('The ratio of sales people to managers is ' + str(ratio))
  print()

for location, staff in staff.items():
  try:
      print_staff_report(location, staff)

  except ZeroDivisionError as e:
      print('Could not print sales report for ' + location)
      print(e)

// Обработка множественных исключений:

Мы можем перечислить более одного типа исключения в кортеже с помощью одного except предложения. 

try:
    # Some code to try!
except (NameError, ZeroDivisionError) as e:
    print('We hit an Exception!')
    print(e)

Помимо перехвата нескольких исключений, мы также можем объединить несколько exceptпредложений с одним try предложением, 
что позволяет обрабатывать определенные исключения по-разному. 

try:
    # Some code to try!
except NameError:
    print('We hit a NameError Exception!')
except KeyError:
    print('We hit a TypeError Exception!')
except Exception:
    print('We hit an exception that is not a NameError or TypeError!')

/

instrument_prices = {
  'Banjo': 200,
  'Cello': 1000,
  'Flute': 100,
}

def display_discounted_price(instrument, discount):
  full_price = instrument_prices[instrument]
  discount_percentage = discount / 100
  discounted_price = full_price - (full_price * discount_percentage)
  print("The instrument's discounted price is: " + str(discounted_price))

instrument = 'Banjo'
discount = '20'


try:
  display_discounted_price(instrument, discount)
except KeyError: 
  print('An invalid instrument was entered!')
except TypeError:
  print('Discount percentage must be a number!')
except Exception:
  print('Hit an exception other than KeyError or TypeError!')

// Пункт else:

try:
  check_password()
except ValueError:
  print('Wrong Password! Try again!')
else:
  login_user()
  # 20 other lines of imaginary code

/

customer_rewards = {
  'Zoltan': 82570,
  'Guadalupe': 29850,
  'Mario': 17849
}

def display_rewards_account(customer):

  try:
    rewards_number = customer_rewards[customer]
    print('Rewards account number is: ' + str(rewards_number))
  except KeyError:
    print('Customer was not found in rewards program!')
  else:
    print('Rewards account number is: ' + str(rewards_number))

customer = 'Mario'
display_rewards_account(customer)

// finally предложение:

мы добавили finallyпредложение, которое будет выполняться независимо от того, не сможет ли пользователь войти в систему или нет. 
В любом случае мы используем воображаемую функцию, вызываемую load_footer() для загрузки нижнего колонтитула страницы. 

try:
  check_password()
except ValueError:
  print('Wrong Password! Try again!')
else:
  login_user()
  # 20 other lines of imaginary code
finally:
  load_footer()

also we can use it only with try:

try:
    check_password()
finally:
    load_footer()
    # Other code we always want to run 

/

import database

instrument = 'Kora'
database.connect_to_database()

try:
  database.display_instrument_info(instrument)
except KeyError:
  print('Oh no! This instrument does not exist.')
else:
  print(instrument)
finally:
  database.disconnect_from_database()

// Пользовательские исключения:

Python дает нам возможность создавать пользовательские исключения

class CustomError(Exception):
    pass

/

class LocationTooFarError(Exception):
   pass
 
def schedule_delivery(distance_from_store):
    if distance_from_store > 10:
        raise LocationTooFarError
    else:
        print('Scheduling the delivery...')

/

inventory = {
  'Piano': 3,
  'Lute': 1,
  'Sitar': 2
}

class InventoryError(Exception):
  pass

def submit_order(instrument, quantity):
  supply = inventory[instrument]

  if quantity > supply:
    raise InventoryError
  else:
    inventory[instrument] -= quantity
    print('Successfully placed order! Remaining supply: ' + str(inventory[instrument]))

instrument = 'Piano'
quantity = 5
submit_order(instrument, quantity)

// Настройка пользовательских исключений:

Вот как может выглядеть пользовательский класс:

class LocationTooFarError(Exception):
   def __init__(self, distance):
       self.distance = distance
 
   def __str__(self):
        return 'Location is not within 10 km: ' + str(self.distance)

/

class InventoryError(Exception):
  def __init__(self, supply):
    self.supply = supply

  def __str__(self):
    return 'Available supply is only ' + str(self.supply)

inventory = {
  'Piano': 3,
  'Lute': 1,
  'Sitar': 2
}

def submit_order(instrument, quantity):
  supply = inventory[instrument]

  if quantity > supply:
    raise InventoryError(supply)
  else:
    inventory[instrument] -= quantity
    print('Successfully placed order! Remaining supply: ' + str(inventory[instrument]))

instrument = 'Piano'
quantity = 5
submit_order(instrument, quantity)













